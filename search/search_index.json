{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"astdoc","text":""},{"location":"#installation","title":"Installation","text":"<p>Install the astdoc using pip:</p> <pre><code>pip install astdoc\n</code></pre>"},{"location":"api/astdoc/","title":"astdoc","text":"astdoc<p> source package astdoc </p> <p>Parse abstract syntax trees (AST) and extracting docstring information.</p> <p> Modules </p> <ul> <li> <p>astdoc.ast \u2014 Provide utilities for working with Abstract Syntax Trees (AST).</p> </li> <li> <p>astdoc.doc \u2014 Process and manage docstrings.</p> </li> <li> <p>astdoc.markdown \u2014 Provide functions for processing and converting Markdown text.</p> </li> <li> <p>astdoc.node \u2014 Node representation module for Abstract Syntax Tree (AST).</p> </li> <li> <p>astdoc.object \u2014 Handle objects in the Abstract Syntax Tree (AST).</p> </li> <li> <p>astdoc.utils \u2014 Utility functions for the application.</p> </li> </ul>"},{"location":"api/astdoc/ast/","title":"astdoc.ast","text":"astdoc.ast<p> source module astdoc.ast </p> <p>Provide utilities for working with Abstract Syntax Trees (AST).</p> <p>Include functions and classes for analyzing, transforming, and manipulating AST nodes, which represent the structure of Python code.</p> <p>Key Features:</p> <ul> <li>Identification of various node types, such as function definitions,   class definitions, assignments, and decorators.</li> <li>Utilities for renaming nodes and transforming AST structures.</li> <li>Functions to extract identifiers and analyze function signatures.</li> <li>Support for decorators, including properties, class methods, and static methods.</li> </ul> <p> Classes </p> <ul> <li> <p>Parameter \u2014 Represent a parameter in a function or method.</p> </li> <li> <p>Transformer \u2014 AST transformer for renaming nodes.</p> </li> <li> <p>StringTransformer \u2014 AST Transformer for renaming string constants.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>iter_child_nodes \u2014 Yield child nodes of the given AST node.</p> </li> <li> <p>get_assign_name \u2014 Return the name of the assign node.</p> </li> <li> <p>get_assign_type \u2014 Return the type annotation of the Assign or TypeAlias AST node.</p> </li> <li> <p>iter_parameters \u2014 Yield <code>Parameter</code> instances from a function node.</p> </li> <li> <p>iter_raises \u2014 Yield unique raises from a function node.</p> </li> <li> <p>create_ast_expr \u2014 Return an <code>ast.expr</code> instance of a name.</p> </li> <li> <p>iter_identifiers \u2014 Yield identifiers from an AST node.</p> </li> <li> <p>unparse \u2014 Unparse the AST node with a callback function.</p> </li> <li> <p>has_decorator \u2014 Check if a class or function has a specific decorator.</p> </li> <li> <p>is_function_def \u2014 Check if the AST node is a function definition.</p> </li> <li> <p>is_property \u2014 Check if the AST node is a property.</p> </li> <li> <p>is_setter \u2014 Check if the AST node is a setter.</p> </li> <li> <p>has_overload \u2014 Check if the AST node has an overload decorator.</p> </li> <li> <p>is_function \u2014 Check if the AST node is a regular function definition.</p> </li> <li> <p>is_classmethod \u2014 Check if the AST node is a class method.</p> </li> <li> <p>is_staticmethod \u2014 Check if the AST node is a static method.</p> </li> <li> <p>is_assign \u2014 Check if the AST node is an assignment.</p> </li> </ul> <p> source iter_child_nodes(node: AST) \u2192 Iterator[AST] </p> <p>Yield child nodes of the given AST node.</p> <p>Traverse the child nodes of the specified Abstract Syntax Tree (AST) node and yield each child node that is of interest, including import statements, class definitions, and function definitions. Allow recursive traversal of the AST structure.</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The AST node from which to yield child nodes.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>AST \u2014 The child nodes of the specified AST node.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\ntree = ast.parse(\"def foo(): pass\")\nfor child in iter_child_nodes(tree):\n    print(type(child))\n</code></pre> <pre><code>&lt;class 'ast.FunctionDef'&gt;\n</code></pre> <p> source get_assign_name(node: AnnAssign | Assign | TypeAlias) \u2192 str | None </p> <p>Return the name of the assign node.</p> <p>Retrieve the name associated with an assignment node, which can be of type AnnAssign, Assign, or TypeAlias. Handle different types of assignment nodes and return the name as a string. If the node does not represent a valid assignment, return None.</p> <p> Parameters </p> <ul> <li> <p>node :  AnnAssign | Assign | TypeAlias \u2014 The assignment node from which to extract the name.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str | None \u2014 The name of the assignment node if found, otherwise None.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nnode = ast.parse(\"x = 1\").body[0]\nget_assign_name(node)\n</code></pre> <pre><code>'x'\n</code></pre> <pre><code>node = ast.parse(\"y: int = 2\").body[0]\nget_assign_name(node)\n</code></pre> <pre><code>'y'\n</code></pre> <p> source get_assign_type(node: AnnAssign | Assign | TypeAlias) \u2192 ast.expr | None </p> <p>Return the type annotation of the Assign or TypeAlias AST node.</p> <p>Retrieve the type annotation associated with an assignment node, which can be of type AnnAssign, Assign, or TypeAlias. Check the node type and return the corresponding type annotation if available. If the node does not represent a valid assignment or does not have a type annotation, return None.</p> <p> Parameters </p> <ul> <li> <p>node :  AnnAssign | Assign | TypeAlias \u2014 The assignment node from which to extract the type annotation.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>ast.expr | None \u2014 The type annotation of the assignment node if found,     otherwise None.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nnode = ast.parse(\"x: int = 1\").body[0]\nget_assign_type(node)\n</code></pre> <pre><code>&lt;ast.Name object at 0x...&gt;\n</code></pre> <pre><code>node = ast.parse(\"y = 2\").body[0]\nget_assign_type(node) is None\n</code></pre> <pre><code>True\n</code></pre> <p> source dataclass Parameter(name: str, type: ast.expr | None, default: ast.expr | None, kind: _ParameterKind) </p> <p>Represent a parameter in a function or method.</p> <p>Encapsulate the details of a parameter, including its name, type annotation, default value, and kind. It is used to provide a structured representation of function parameters, making it easier to analyze and manipulate function signatures.</p> <p> Attributes </p> <ul> <li> <p>name :  str \u2014 The name of the parameter.</p> </li> <li> <p>type :  ast.expr | None \u2014 The type annotation of the parameter, represented as an AST expression. This can be None if no type annotation is provided.</p> </li> <li> <p>default :  ast.expr | None \u2014 The default value of the parameter, represented as an AST expression. This can be None if the parameter does not have a default value.</p> </li> <li> <p>kind :  _ParameterKind \u2014 The kind of the parameter, indicating whether it is positional-only, positional-or-keyword, keyword-only, or variable.</p> </li> </ul> <p> source iter_parameters(node: FunctionDef | AsyncFunctionDef) \u2192 Iterator[Parameter] </p> <p>Yield <code>Parameter</code> instances from a function node.</p> <p>Extract parameters from a function definition node, which can be either a synchronous or asynchronous function. Utilize the helper function <code>_iter_parameters</code> to retrieve the parameter names, type annotations, and kinds. Additionally, use <code>_iter_defaults</code> to obtain the default values for parameters that have them. The function yields instances of the <code>Parameter</code> class, encapsulating the details of each parameter.</p> <p> Parameters </p> <ul> <li> <p>node :  FunctionDef | AsyncFunctionDef \u2014 The function definition node from which to extract parameters.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Parameter \u2014 An instance of the <code>Parameter</code> class for each parameter defined in the function, containing the name, type annotation, default value (if any), and kind.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nsrc = \"def func(a, b: int, *args, c: str, d=5, **kwargs): pass\"\nnode = ast.parse(src).body[0]\nparams = list(iter_parameters(node))\nparams[0].name\n</code></pre> <pre><code>'a'\n</code></pre> <pre><code>params[1].type.id\n</code></pre> <pre><code>'int'\n</code></pre> <pre><code>params[1].default is None\n</code></pre> <pre><code>True\n</code></pre> <pre><code>params[4].default.value\n</code></pre> <pre><code>5\n</code></pre> <p> source iter_raises(node: FunctionDef | AsyncFunctionDef) \u2192 Iterator[ast.expr] </p> <p>Yield unique raises from a function node.</p> <p>Traverse the Abstract Syntax Tree (AST) of a function definition node, which can be either synchronous or asynchronous. Identify and yield unique exception types that are raised within the function. The function checks for <code>Raise</code> statements and extracts the exception type, ensuring that each type is yielded only once.</p> <p> Parameters </p> <ul> <li> <p>node :  FunctionDef | AsyncFunctionDef \u2014 The function definition node from which to extract raised exceptions.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>ast.expr \u2014 The unique exception types raised within the function.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nsrc = \"def func(): raise ValueError('error')\"\nnode = ast.parse(src).body[0]\nraises = list(iter_raises(node))\nlen(raises)\n</code></pre> <pre><code>1\n</code></pre> <pre><code>ast.unparse(raises[0])\n</code></pre> <pre><code>'ValueError'\n</code></pre> <p> source create_ast_expr(name: str) \u2192 ast.expr </p> <p>Return an <code>ast.expr</code> instance of a name.</p> <p>Create and return an Abstract Syntax Tree (AST) expression representing the given name. First, check if the name is a valid identifier. If it is, attempt to parse the name into an AST node. If the parsing is successful and the resulting node is an expression, return the value of that expression. If the name is not a valid identifier or if a SyntaxError occurs during parsing, return a Constant expression with an empty string.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name to convert into an AST expression.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>ast.expr \u2014 An AST expression representing the name, or a Constant expression if the name is invalid or cannot be parsed.</p> </li> </ul> <p> Examples </p> <pre><code>create_ast_expr(\"x\").id\n</code></pre> <pre><code>'x'\n</code></pre> <pre><code>create_ast_expr(\"invalid name\").value\n</code></pre> <pre><code>''\n</code></pre> <pre><code>create_ast_expr(\"42\").value\n</code></pre> <pre><code>'42'\n</code></pre> <p> source class Transformer() </p> <p>Bases : NodeTransformer</p> <p>AST transformer for renaming nodes.</p> <p>Extend the <code>NodeTransformer</code> to provide functionality for renaming Abstract Syntax Tree (AST) nodes. Traverse the AST and modify specific nodes according to the renaming rules defined within the class. The primary purpose of this transformer is to prepend the specified prefix (<code>.</code>) to the names of nodes, allowing for systematic renaming during AST transformations.</p> <p> Examples </p> <pre><code>transformer = Transformer()\nnode = ast.parse(\"x = 1\")\ntransformer.unparse(node)\n</code></pre> <pre><code>'__astdoc__.x = 1'\n</code></pre> <p> Methods </p> <ul> <li> <p>visit_Name \u2014 Visit a <code>Name</code> node and rename it if it is not already renamed.</p> </li> <li> <p>unparse \u2014 Convert the transformed AST node back into source code.</p> </li> </ul> <p> source method Transformer.visit_Name(node: Name) \u2192 Name </p> <p>Visit a <code>Name</code> node and rename it if it is not already renamed.</p> <p> source method Transformer.unparse(node: AST) \u2192 str </p> <p>Convert the transformed AST node back into source code.</p> <p>Take an Abstract Syntax Tree (AST) node, apply the transformations defined in the <code>visit</code> methods of the transformer, and return the corresponding source code as a string. To avoid in-place renaming, it first creates a copy of the node by parsing the unparsed version of the original node.</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The AST node to be transformed and converted back into source code.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The source code representation of the transformed AST node.</p> </li> </ul> <p> Examples </p> <pre><code>transformer = Transformer()\nnode = ast.parse(\"a.b.c\")\ntransformer.unparse(node)\n</code></pre> <pre><code>'__astdoc__.a.b.c'\n</code></pre> <p> source class StringTransformer() </p> <p>Bases : Transformer</p> <p>AST Transformer for renaming string constants.</p> <p>Extend the <code>Transformer</code> to provide functionality for renaming string constant nodes in the Abstract Syntax Tree (AST). Traverse the AST and modify <code>Constant</code> nodes that contain string values by renaming them according to the rules defined in the parent class.</p> <p> Methods </p> <ul> <li> <p>visit_Constant \u2014 Visit a <code>Constant</code> node and rename it if its value is a string.</p> </li> </ul> <p> source method StringTransformer.visit_Constant(node: Constant) \u2192 Constant | Name </p> <p>Visit a <code>Constant</code> node and rename it if its value is a string.</p> <p>Override the <code>visit_Constant</code> method from the <code>Transformer</code> class. Check if the value of the <code>Constant</code> node is a string, and if so, rename the string using the <code>_rename</code> method. If the value is not a string, return the node unchanged.</p> <p> Parameters </p> <ul> <li> <p>node :  Constant \u2014 The <code>Constant</code> node to be visited and potentially renamed.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Constant | Name \u2014 The renamed <code>Constant</code> node if its value is a string, otherwise the original <code>Constant</code> node.</p> </li> </ul> <p> Examples </p> <pre><code>transformer = StringTransformer()\nnode = ast.parse('\"hello\"')\ntransformer.unparse(node)\n</code></pre> <pre><code>'__astdoc__.hello'\n</code></pre> <p> source iter_identifiers(node: AST) \u2192 Iterator[str] </p> <p>Yield identifiers from an AST node.</p> <p>Extract identifiers from the given Abstract Syntax Tree (AST) node by first converting the node back into source code using the <code>StringTransformer</code>. Scan the resulting source code for segments that may represent valid Python identifiers. Only valid identifiers are yielded.</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The AST node from which to extract identifiers.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>str \u2014 Each valid identifier found in the AST node's source code.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nsrc = \"'a[b]'\"\nnode = ast.parse(src)\nidentifiers = list(iter_identifiers(node))\nidentifiers\n</code></pre> <pre><code>['a']\n</code></pre> <p> source unparse(node: AST, callback: Callable[[str], str], *, is_type: bool = True) \u2192 str </p> <p>Unparse the AST node with a callback function.</p> <p>Take an Abstract Syntax Tree (AST) node and a callback function, and convert the AST node back into source code. The callback function is applied to each identifier found in the AST, allowing for custom transformations of the identifiers during the unparse process. The <code>is_type</code> parameter determines whether the transformation is for type-related nodes or general nodes.</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The AST node to be converted back into source code.</p> </li> <li> <p>callback :  Callable[[str], str] \u2014 A function that takes a string (identifier) and returns a transformed string.</p> </li> <li> <p>is_type :  bool, optional \u2014 A flag indicating whether the transformation is for type-related nodes. Defaults to True.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The source code representation of the unparsed AST node.</p> </li> </ul> <p> Examples </p> <pre><code>def transform(identifier: str) -&gt; str:\n    return f\"&lt;{identifier}&gt;\"\nsrc = \"a + b\"\nnode = ast.parse(src)\nunparse(node, transform)\n</code></pre> <pre><code>'&lt;a&gt; + &lt;b&gt;'\n</code></pre> <p> source has_decorator(node: AST, name: str, index: int = 0) \u2192 bool </p> <p>Check if a class or function has a specific decorator.</p> <p>Check whether the given Abstract Syntax Tree (AST) node, which can be a class definition or a function definition (synchronous or asynchronous), has a decorator with the specified name. Traverse the decorator list of the node and compare the names of the decorators to the provided name. The <code>index</code> parameter allows for checking decorators at a specific position in the decorator list.</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The AST node to inspect for decorators.</p> </li> <li> <p>name :  str \u2014 The name of the decorator to check for.</p> </li> <li> <p>index :  int, optional \u2014 The index of the decorator in the list to check. Defaults to 0, which checks for the first decorator.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the specified decorator is found at the given index, False otherwise.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nsrc = \"@my_decorator\\ndef func():\\n pass\"\nnode = ast.parse(src).body[0]\nhas_decorator(node, \"my_decorator\")\n</code></pre> <pre><code>True\n</code></pre> <pre><code>has_decorator(node, \"other_decorator\")\n</code></pre> <pre><code>False\n</code></pre> <p> source is_function_def(node: AST) \u2192 TypeGuard[FunctionDef | AsyncFunctionDef] </p> <p>Check if the AST node is a function definition.</p> <p>Determine whether the given Abstract Syntax Tree (AST) node is a function definition, which can be either a synchronous or asynchronous function.</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The AST node to check.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the node is a function definition, otherwise False.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nsrc = \"def func(): pass\"\nnode = ast.parse(src).body[0]\nis_function_def(node)\n</code></pre> <pre><code>True\n</code></pre> <p> source is_property(node: AST) \u2192 TypeGuard[FunctionDef | AsyncFunctionDef] </p> <p>Check if the AST node is a property.</p> <p>Determine whether the given AST node is a function definition and has a decorator named \"property\".</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The AST node to check.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the node is a property, otherwise False.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nsrc = \"@property\\ndef func(self): pass\"\nnode = ast.parse(src).body[0]\nis_property(node)\n</code></pre> <pre><code>True\n</code></pre> <pre><code>src = \"@cached_property\\ndef func(self): pass\"\nnode = ast.parse(src).body[0]\nis_property(node)\n</code></pre> <pre><code>True\n</code></pre> <pre><code>src = \"@functools.cached_property\\ndef func(self): pass\"\nnode = ast.parse(src).body[0]\nis_property(node)\n</code></pre> <pre><code>True\n</code></pre> <p> source is_setter(node: AST) \u2192 TypeGuard[FunctionDef | AsyncFunctionDef] </p> <p>Check if the AST node is a setter.</p> <p>Determine whether the given AST node is a function definition and has a decorator named \"setter\" at the specified index.</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The AST node to check.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the node is a setter, otherwise False.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nsrc = \"@func.setter\\ndef func(self, value): pass\"\nnode = ast.parse(src).body[0]\nis_setter(node)\n</code></pre> <pre><code>True\n</code></pre> <p> source has_overload(node: AST) \u2192 TypeGuard[FunctionDef | AsyncFunctionDef] </p> <p>Check if the AST node has an overload decorator.</p> <p>Determine whether the given Abstract Syntax Tree (AST) node is a function definition and has a decorator named \"overload\".</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The AST node to check.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the node has an overload decorator, otherwise False.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nsrc = \"@overload\\ndef func(self): pass\"\nnode = ast.parse(src).body[0]\nhas_overload(node)\n</code></pre> <pre><code>True\n</code></pre> <p> source is_function(node: AST) \u2192 TypeGuard[FunctionDef | AsyncFunctionDef] </p> <p>Check if the AST node is a regular function definition.</p> <p>Determine whether the given Abstract Syntax Tree (AST) node is a function definition and ensures that it is not a property, setter, or overload.</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The AST node to check.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the node is a regular function definition, otherwise False.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nsrc = \"def func(): pass\"\nnode = ast.parse(src).body[0]\nis_function(node)\n</code></pre> <pre><code>True\n</code></pre> <pre><code>src = \"@property\\ndef func(self): pass\"\nnode = ast.parse(src).body[0]\nis_function(node)\n</code></pre> <pre><code>False\n</code></pre> <p> source is_classmethod(node: AST) \u2192 TypeGuard[FunctionDef | AsyncFunctionDef] </p> <p>Check if the AST node is a class method.</p> <p>Determine whether the given Abstract Syntax Tree (AST) node is a function definition and has a decorator named \"classmethod\".</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The AST node to check.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the node is a class method, otherwise False.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nsrc = \"@classmethod\\ndef func(cls): pass\"\nnode = ast.parse(src).body[0]\nis_classmethod(node)\n</code></pre> <pre><code>True\n</code></pre> <p> source is_staticmethod(node: AST) \u2192 TypeGuard[FunctionDef | AsyncFunctionDef] </p> <p>Check if the AST node is a static method.</p> <p>Determine whether the given Abstract Syntax Tree (AST) node is a function definition and has a decorator named \"staticmethod\".</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The AST node to check.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the node is a static method, otherwise False.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nsrc = \"@staticmethod\\ndef func(): pass\"\nnode = ast.parse(src).body[0]\nis_staticmethod(node)\n</code></pre> <pre><code>True\n</code></pre> <p> source is_assign(node: AST) \u2192 TypeGuard[ast.AnnAssign | ast.Assign | TypeAlias] </p> <p>Check if the AST node is an assignment.</p> <p>Determine whether the given Abstract Syntax Tree (AST) node is an assignment statement, which can be an annotated assignment, a regular assignment, or a type alias.</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The AST node to check.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the node is an assignment, otherwise False.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nsrc = \"x: int = 5\"\nnode = ast.parse(src).body[0]\nis_assign(node)\n</code></pre> <pre><code>True\n</code></pre>"},{"location":"api/astdoc/doc/","title":"astdoc.doc","text":"astdoc.doc<p> source module astdoc.doc </p> <p>Process and manage docstrings.</p> <p>Provide functionality for parsing, organizing, and manipulating docstrings in various formats, specifically Google and NumPy styles. It defines data structures and utility functions to facilitate the extraction of structured information from docstrings, including parameters, return values, and sections.</p> <p>Key Classes:</p> <ul> <li>Item: Represents an individual item in a docstring, such as a   parameter or return value, encapsulating its name, type, and description.</li> <li>Section: Represents a section in a docstring, containing a name,   type, description, and a list of associated items.</li> <li>Doc: Represents a complete docstring, including its type, main   text content, and sections.</li> </ul> <p> Classes </p> <ul> <li> <p>Item \u2014 Represent an item in a docstring.</p> </li> <li> <p>Section \u2014 Represent a section in a docstring.</p> </li> <li> <p>Doc \u2014 Represent a docstring.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>split_item \u2014 Split a text item into its components based on the specified style.</p> </li> <li> <p>split_item_without_name \u2014 Return a tuple of (type, text) for Returns or Yields section.</p> </li> <li> <p>iter_items \u2014 Yield <code>Item</code> instances from the provided text based on the specified style.</p> </li> <li> <p>iter_items_without_name \u2014 Yield <code>Item</code> instances without a name from the provided text based.</p> </li> <li> <p>get_style \u2014 Return the docstring style based on the provided text.</p> </li> <li> <p>split_section \u2014 Return a section name and its text based on the specified style.</p> </li> <li> <p>iter_sections \u2014 Yield <code>Section</code> instances by splitting a docstring.</p> </li> <li> <p>normalize_code_block_indentation \u2014 Normalize indentation of code blocks in the given text.</p> </li> <li> <p>clean_section \u2014 Clean up a section by normalizing its code blocks.</p> </li> <li> <p>create_doc \u2014 Create and return a <code>Doc</code> instance from the provided text.</p> </li> <li> <p>create_doc_comment \u2014 Create and return a <code>Doc</code> instance from a docstring comment.</p> </li> <li> <p>split_type \u2014 Split the type and text of a <code>Doc</code> instance.</p> </li> <li> <p>merge_items \u2014 Merge two <code>Item</code> instances into one <code>Item</code> instance.</p> </li> <li> <p>iter_merged_items \u2014 Yield merged <code>Item</code> instances from two lists of <code>Item</code>.</p> </li> <li> <p>merge_sections \u2014 Merge two <code>Section</code> instances into one <code>Section</code> instance.</p> </li> <li> <p>iter_merged_sections \u2014 Yield merged <code>Section</code> instances from two lists of <code>Section</code>.</p> </li> <li> <p>merge \u2014 Merge two <code>Doc</code> instances into one <code>Doc</code> instance.</p> </li> <li> <p>is_empty \u2014 Return True if a <code>Doc</code> instance is empty.</p> </li> </ul> <p> source split_item(text: str, style: Style) \u2192 tuple[str, str, str] </p> <p>Split a text item into its components based on the specified style.</p> <p>Take a string representing an item and a style indicator (either \"google\" or \"numpy\") and splits the item into a tuple containing the name, type, and text description. Delegate the actual splitting to the appropriate helper function based on the specified style.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The input text item to be split.</p> </li> <li> <p>style :  Style \u2014 The style to use for splitting the item, either \"google\" or \"numpy\".</p> </li> </ul> <p> Returns </p> <ul> <li> <p>tuple[str, str, str] \u2014 A tuple containing the name, type, and text description of the item.</p> </li> </ul> <p> Examples </p> <pre><code>text = \"param1 (int): The first parameter.\"\nsplit_item(text, \"google\")\n</code></pre> <pre><code>('param1', 'int', 'The first parameter.')\n</code></pre> <p> source split_item_without_name(text: str, style: str) \u2192 tuple[str, str] </p> <p>Return a tuple of (type, text) for Returns or Yields section.</p> <p>Process the input text to extract the type and description for the Returns or Yields section of a docstring, based on the specified style. Handle both Google and NumPy styles, returning the appropriate components as a tuple.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The input text from which to extract the type and description.</p> </li> <li> <p>style :  str \u2014 The style to use for processing the text, either \"google\" or \"numpy\".</p> </li> </ul> <p> Returns </p> <ul> <li> <p>tuple[str, str] \u2014 A tuple containing the type and the text description. If the type cannot be determined, an empty string is returned as the type.</p> </li> </ul> <p> Examples </p> <pre><code>text = \"int: The return value.\"\nsplit_item_without_name(text, \"google\")\n</code></pre> <pre><code>('int', 'The return value.')\n</code></pre> <pre><code>text = \"str\\n    The output string.\"\nsplit_item_without_name(text, \"numpy\")\n</code></pre> <pre><code>('str', 'The output string.')\n</code></pre> <p> source dataclass Item(name: str, type: str | ast.expr | None, text: str) </p> <p>Represent an item in a docstring.</p> <p>Encapsulate the details of a single item found in a docstring, such as a parameter, return value, or exception. It stores the name, type, and description of the item, providing a structured way to manage and access this information.</p> <p> Examples </p> <pre><code>item = Item(name=\"param1\", type=\"int\", text=\"The first parameter.\")\nitem.name\n</code></pre> <pre><code>'param1'\n</code></pre> <pre><code>item.type\n</code></pre> <pre><code>'int'\n</code></pre> <pre><code>item.text\n</code></pre> <pre><code>'The first parameter.'\n</code></pre> <pre><code>repr(item)\n</code></pre> <pre><code>\"Item('param1')\"\n</code></pre> <p> Attributes </p> <ul> <li> <p>name :  str \u2014 The name of the item, typically representing a parameter, return value, or exception.</p> </li> <li> <p>type :  str | ast.expr | None \u2014 The type of the item, which can be a string representation of the type, an Abstract Syntax Tree (AST) expression, or None if the type is not specified.</p> </li> <li> <p>text :  str \u2014 A description or documentation text associated with the item.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>clone \u2014 Clone the current <code>Item</code> instance.</p> </li> </ul> <p> source method Item.clone() \u2192 Item </p> <p>Clone the current <code>Item</code> instance.</p> <p> source iter_items(text: str, style: Style) \u2192 Iterator[Item] </p> <p>Yield <code>Item</code> instances from the provided text based on the specified style.</p> <p>Process the input text to extract items formatted according to the specified style (either \"google\" or \"numpy\"). It iterates over the items found in the text, splits each item into its components (name, type, and text), and yields instances of the Item class.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The input text containing items to be processed.</p> </li> <li> <p>style :  Style \u2014 The style to use for splitting the items, either \"google\" or \"numpy\".</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Iterator[Item] \u2014 Each <code>Item</code> instance created from the extracted components of the items found in the text.</p> </li> </ul> <p> Examples </p> <pre><code>text = \"param1 (int): The first.\\nparam2 (str): The second.\"\nitems = list(iter_items(text, \"google\"))\nlen(items)\n</code></pre> <pre><code>2\n</code></pre> <pre><code>items[0].name\n</code></pre> <pre><code>'param1'\n</code></pre> <pre><code>items[0].type\n</code></pre> <pre><code>'int'\n</code></pre> <pre><code>items[0].text\n</code></pre> <pre><code>'The first.'\n</code></pre> <p> source iter_items_without_name(text: str, style: Style) \u2192 Iterator[Item] </p> <p>Yield <code>Item</code> instances without a name from the provided text based.</p> <p>Process the input text to extract items formatted according to the specified style (either \"google\" or \"numpy\") but does not include the name of the item in the resulting <code>Item</code> instances. It is particularly useful for sections like Returns or Yields where the name is not specified.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The input text containing items to be processed.</p> </li> <li> <p>style :  Style \u2014 The style to use for processing the text, either \"google\" or \"numpy\".</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Iterator[Item] \u2014 Each <code>Item</code> instance created from the extracted components of the items found in the text, without a name.</p> </li> </ul> <p> Examples </p> <pre><code>text = \"int: The return value.\"\nitems = list(iter_items_without_name(text, \"google\"))\nlen(items)\n</code></pre> <pre><code>1\n</code></pre> <pre><code>items[0].type\n</code></pre> <pre><code>'int'\n</code></pre> <pre><code>items[0].text\n</code></pre> <pre><code>'The return value.'\n</code></pre> <p> source get_style(text: str) \u2192 Style </p> <p>Return the docstring style based on the provided text.</p> <p>Analyze the input text to determine whether it follows the Google or NumPy style for docstrings. Check for specific section headers and formatting patterns to identify the style. If the style cannot be determined, it defaults to returning the Google style.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The input text containing the docstring to be analyzed.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Style \u2014 The determined style of the docstring, either \"google\" or \"numpy\".</p> </li> </ul> <p> Examples </p> <pre><code>text = \"Parameters:\\n    param1 (int): The first parameter.\"\nget_style(text)\n</code></pre> <pre><code>'google'\n</code></pre> <pre><code>text = \"\\n\\nReturns\\n--------\\n    str: The output string.\"\nget_style(text)\n</code></pre> <pre><code>'numpy'\n</code></pre> <pre><code>get_style(\"\")\n</code></pre> <pre><code>'google'\n</code></pre> <p> source split_section(text: str, style: Style) \u2192 tuple[str, str] </p> <p>Return a section name and its text based on the specified style.</p> <p>Process the input text to extract the section name and its corresponding content. Identify the section name based on the formatting style (either \"google\" or \"numpy\") and return the name along with the text that follows it.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The input text representing a section, which may include a section header followed by indented content.</p> </li> <li> <p>style :  Style \u2014 The style to use for processing the section, either \"google\" or \"numpy\".</p> </li> </ul> <p> Returns </p> <ul> <li> <p>tuple[str, str] \u2014 A tuple containing the section name and the text associated with that section. If the section name cannot be determined, an empty string is returned as the name.</p> </li> </ul> <p> Examples </p> <pre><code>text = \"Args:\\n    param1 (int): The first parameter.\"\nsplit_section(text, \"google\")\n</code></pre> <pre><code>('Args', 'param1 (int): The first parameter.')\n</code></pre> <pre><code>text = \"Returns\\n--------\\n    str: The output string.\"\nsplit_section(text, \"numpy\")\n</code></pre> <pre><code>('Returns', 'str: The output string.')\n</code></pre> <p> source dataclass Section(name: str, type: str | ast.expr | None, text: str, items: list[Item]) </p> <p>Bases : Item</p> <p>Represent a section in a docstring.</p> <p>Encapsulate the details of a section found in a docstring. A section typically contains a name, an optional type, a description, and a list of items that belong to that section. Provide a structured way to manage and access the information related to a specific part of the documentation.</p> <p> Attributes </p> <ul> <li> <p>name :  str \u2014 The name of the section, such as \"Parameters\", \"Returns\", or \"Attributes\".</p> </li> <li> <p>type :  str \u2014 The type of the section, which can provide additional context about the section's content.</p> </li> <li> <p>text :  str \u2014 A description or documentation text associated with the section.</p> </li> <li> <p>items :  list[Item] \u2014 A list of <code>Item</code> instances that belong to this section, representing individual parameters, return values, or exceptions.</p> </li> </ul> <p> Examples </p> <pre><code>section = Section(name=\"Parameters\", type=\"\", text=\"The text.\", items=[])\nsection.name\n</code></pre> <pre><code>'Parameters'\n</code></pre> <pre><code>section.items\n</code></pre> <pre><code>[]\n</code></pre> <p> Methods </p> <ul> <li> <p>clone \u2014 Clone the current <code>Section</code> instance.</p> </li> </ul> <p> source method Section.clone() \u2192 Section </p> <p>Clone the current <code>Section</code> instance.</p> <p> source iter_sections(text: str, style: Style) \u2192 Iterator[Section] </p> <p>Yield <code>Section</code> instances by splitting a docstring.</p> <p>Process the input text to extract sections formatted according to the specified style (either \"google\" or \"numpy\"). Split the text into sections, yielding <code>Section</code> instances for each identified section. Handle special sections such as \"Note\", \"Warning\", and \"See Also\" by creating admonition blocks.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The input text containing the docstring to be processed.</p> </li> <li> <p>style :  Style \u2014 The style to use for splitting the sections, either \"google\" or \"numpy\".</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Section \u2014 Each <code>Section</code> instance created from the extracted components of the sections found in the text.</p> </li> </ul> <p> Examples </p> <pre><code>text = \"Parameters:\\n    param1 (int): The first parameter.\\n\\n\"\ntext += \"Returns:\\n    str: The output string.\"\nsections = list(iter_sections(text, \"google\"))\nlen(sections)\n</code></pre> <pre><code>2\n</code></pre> <pre><code>sections[0].name\n</code></pre> <pre><code>'Parameters'\n</code></pre> <pre><code>sections[1].name\n</code></pre> <pre><code>'Returns'\n</code></pre> <p> source normalize_code_block_indentation(text: str) \u2192 str </p> <p>Normalize indentation of code blocks in the given text.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 Text containing possibly indented code blocks.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 Text with normalized code block indentation.</p> </li> </ul> <p> source clean_section(section: Section) \u2192 Section </p> <p>Clean up a section by normalizing its code blocks.</p> <p> source dataclass Doc(name: str, type: str | ast.expr | None, text: str, sections: list[Section]) </p> <p>Bases : Item</p> <p>Represent a docstring.</p> <p>Encapsulate the details of a docstring, including its type, text content, and the sections it contains. Provide a structured way to manage and access the information related to the documentation, allowing for easier processing and manipulation.</p> <p> Attributes </p> <ul> <li> <p>name :  str \u2014 The name of the documentation, typically representing the overall subject or purpose of the docstring.</p> </li> <li> <p>type :  str \u2014 The type of the documentation, which can provide additional context about the content.</p> </li> <li> <p>text :  str \u2014 The main text content of the documentation, which may include introductory information or general descriptions.</p> </li> <li> <p>sections :  list[Section] \u2014 A list of <code>Section</code> instances that represent the structured sections within the documentation, such as Parameters, Returns, and Examples.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>clone \u2014 Clone the current <code>Doc</code> instance.</p> </li> </ul> <p> source method Doc.clone() \u2192 Doc </p> <p>Clone the current <code>Doc</code> instance.</p> <p> source create_doc(text: str | None, style: Style | None = None) \u2192 Doc </p> <p>Create and return a <code>Doc</code> instance from the provided text.</p> <p>Take a string representing a documentation text and an optional style indicator (either \"google\" or \"numpy\"). Process the input text to convert it into a structured <code>Doc</code> instance, which includes the main text content and any sections extracted from the text.</p> <p> Parameters </p> <ul> <li> <p>text :  str | None \u2014 The input text to be converted into a <code>Doc</code> instance. If None, an empty <code>Doc</code> instance is returned.</p> </li> <li> <p>style :  Style | None \u2014 The style to use for processing the text, either \"google\" or \"numpy\". If not provided, the style is inferred from the text.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Doc \u2014 A <code>Doc</code> instance containing the structured documentation information.</p> </li> </ul> <p> Examples </p> <pre><code>text = \"Parameters:\\n    param1 (int): The first parameter.\\n\\n\"\ntext += \"Returns:\\n    str: The output string.\"\ndoc = create_doc(text, \"google\")\ndoc.name\n</code></pre> <pre><code>'Doc'\n</code></pre> <pre><code>len(doc.sections)\n</code></pre> <pre><code>2\n</code></pre> <p> source create_doc_comment(text: str) \u2192 Doc </p> <p>Create and return a <code>Doc</code> instance from a docstring comment.</p> <p>Take a string representing a docstring comment (typically from a Returns or Yields section) and convert it into a structured <code>Doc</code> instance. Extract the type and text description from the input text and initialize a <code>Doc</code> instance with this information.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The input text representing the docstring comment to be converted into a <code>Doc</code> instance.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Doc \u2014 A <code>Doc</code> instance containing the type and text extracted from the input comment, with an empty list of sections.</p> </li> </ul> <p> Examples </p> <pre><code>doc_comment = create_doc_comment(\"str: The output string.\")\ndoc_comment.name\n</code></pre> <pre><code>'Doc'\n</code></pre> <pre><code>doc_comment.type\n</code></pre> <pre><code>'str'\n</code></pre> <pre><code>doc_comment.text\n</code></pre> <pre><code>'The output string.'\n</code></pre> <pre><code>len(doc_comment.sections)\n</code></pre> <pre><code>0\n</code></pre> <p> source split_type(doc: Doc) \u2192 None </p> <p>Split the type and text of a <code>Doc</code> instance.</p> <p>Check if the type of the provided <code>Doc</code> instance is not set and if the text is available. If both conditions are met, extract the type and text from the <code>Doc</code>'s text using the <code>split_item_without_name</code> function, assuming the text follows the Google style format.</p> <p> Parameters </p> <ul> <li> <p>doc :  Doc \u2014 The <code>Doc</code> instance whose type and text are to be split.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>None \u2014 This function modifies the <code>Doc</code> instance in place and does not return a value.</p> </li> </ul> <p> Examples </p> <pre><code>doc = Doc(name=\"Doc\", type=\"\", text=\"str: The output string.\", sections=[])\nsplit_type(doc)\ndoc.type\n</code></pre> <pre><code>'str'\n</code></pre> <pre><code>doc.text\n</code></pre> <pre><code>'The output string.'\n</code></pre> <p> source merge_items(a: Item, b: Item) \u2192 Item </p> <p>Merge two <code>Item</code> instances into one <code>Item</code> instance.</p> <p>Combine the attributes of two <code>Item</code> instances, taking the first item's name and the type from either item (if one is missing). The text from both items is concatenated with a double newline in between.</p> <p> Parameters </p> <ul> <li> <p>a :  Item \u2014 The first <code>Item</code> instance to merge.</p> </li> <li> <p>b :  Item \u2014 The second <code>Item</code> instance to merge.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Item \u2014 A new <code>Item</code> instance containing the merged attributes from both input items.</p> </li> </ul> <p> Examples </p> <pre><code>item1 = Item(name=\"param1\", type=\"int\", text=\"The first parameter.\")\nitem2 = Item(name=\"param2\", type=\"str\", text=\"The second parameter.\")\nmerged_item = merge_items(item1, item2)\nmerged_item.name\n</code></pre> <pre><code>'param1'\n</code></pre> <pre><code>merged_item.type\n</code></pre> <pre><code>'int'\n</code></pre> <pre><code>merged_item.text\n</code></pre> <pre><code>'The first parameter.\\n\\nThe second parameter.'\n</code></pre> <p> source iter_merged_items(a: list[Item], b: list[Item]) \u2192 Iterator[Item] </p> <p>Yield merged <code>Item</code> instances from two lists of <code>Item</code>.</p> <p>Take two lists of <code>Item</code> instances and yield merged <code>Item</code> instances based on their names. If an <code>Item</code> exists in both lists, merge them into a single <code>Item</code>. If an <code>Item</code> exists in only one list, yield that <code>Item</code> as is.</p> <p> Parameters </p> <ul> <li> <p>a :  list[Item] \u2014 The first list of <code>Item</code> instances to merge.</p> </li> <li> <p>b :  list[Item] \u2014 The second list of <code>Item</code> instances to merge.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Iterator[Item] \u2014 Each merged <code>Item</code> instance or an <code>Item</code> from one of the lists if it does not have a counterpart in the other list.</p> </li> </ul> <p> Examples </p> <pre><code>item1 = Item(name=\"param1\", type=\"int\", text=\"The first parameter.\")\nitem2 = Item(name=\"param2\", type=\"str\", text=\"The second parameter.\")\nitem3 = Item(name=\"param1\", type=\"float\", text=\"Updated first parameter.\")\nmerged_items = list(iter_merged_items([item1, item2], [item3]))\nlen(merged_items)\n</code></pre> <pre><code>2\n</code></pre> <pre><code>merged_items[0].name\n</code></pre> <pre><code>'param1'\n</code></pre> <pre><code>merged_items[1].name\n</code></pre> <pre><code>'param2'\n</code></pre> <pre><code>merged_items[0].type\n</code></pre> <pre><code>'int'\n</code></pre> <pre><code>merged_items[0].text\n</code></pre> <pre><code>'The first parameter.\\n\\nUpdated first parameter.'\n</code></pre> <p> source merge_sections(a: Section, b: Section) \u2192 Section </p> <p>Merge two <code>Section</code> instances into one <code>Section</code> instance.</p> <p>Combine the attributes of two <code>Section</code> instances, taking the first section's name and the type from either section (if one is missing). The text from both sections is concatenated with a double newline in between, and the items from both sections are merged.</p> <p> Parameters </p> <ul> <li> <p>a :  Section \u2014 The first <code>Section</code> instance to merge.</p> </li> <li> <p>b :  Section \u2014 The second <code>Section</code> instance to merge.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Section \u2014 A new <code>Section</code> instance containing the merged attributes from both input sections.</p> </li> </ul> <p> source iter_merged_sections(a: list[Section], b: list[Section]) \u2192 Iterator[Section] </p> <p>Yield merged <code>Section</code> instances from two lists of <code>Section</code>.</p> <p>Take two lists of <code>Section</code> instances and yield merged <code>Section</code> instances based on their names. If a <code>Section</code> exists in both lists, it merges them into a single <code>Section</code>. If a <code>Section</code> exists in only one list, it yields that <code>Section</code> as is.</p> <p> Parameters </p> <ul> <li> <p>a :  list[Section] \u2014 The first list of <code>Section</code> instances to merge.</p> </li> <li> <p>b :  list[Section] \u2014 The second list of <code>Section</code> instances to merge.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Iterator[Section] \u2014 Each merged <code>Section</code> instance or a <code>Section</code> from one of the lists if it does not have a counterpart in the other list.</p> </li> </ul> <p> source merge(a: Doc, b: Doc) \u2192 Doc </p> <p>Merge two <code>Doc</code> instances into one <code>Doc</code> instance.</p> <p>Combine the attributes of two <code>Doc</code> instances, taking the type from either instance (if one is missing) and concatenating their text content with a double newline in between. It also merges the sections from both <code>Doc</code> instances into a single list of sections.</p> <p> Parameters </p> <ul> <li> <p>a :  Doc \u2014 The first <code>Doc</code> instance to merge.</p> </li> <li> <p>b :  Doc \u2014 The second <code>Doc</code> instance to merge.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Doc \u2014 A new <code>Doc</code> instance containing the merged attributes from both input <code>Doc</code> instances.</p> </li> </ul> <p> source is_empty(doc: Doc) \u2192 bool </p> <p>Return True if a <code>Doc</code> instance is empty.</p> <p>Check whether the provided <code>Doc</code> instance contains any text or sections with text. It returns True if the <code>Doc</code> instance is considered empty, meaning it has no main text, no sections with text, and no items with text. Otherwise, it returns False.</p> <p> Parameters </p> <ul> <li> <p>doc :  Doc \u2014 The <code>Doc</code> instance to check for emptiness.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the <code>Doc</code> instance is empty; otherwise, False.</p> </li> </ul>"},{"location":"api/astdoc/markdown/","title":"astdoc.markdown","text":"astdoc.markdown<p> source module astdoc.markdown </p> <p>Provide functions for processing and converting Markdown text.</p> <p>Include utilities for handling code blocks, links, and examples within Markdown content. The functions are designed to facilitate the extraction, transformation, and formatting of Markdown elements, making it easier to generate well-structured documentation.</p> <p>Key functionalities include:</p> <ul> <li>Iterate over matches of regex patterns in text.</li> <li>Handle fenced and inline code blocks.</li> <li>Escape and unescape specific patterns for processing.</li> </ul> <p> Functions </p> <ul> <li> <p>set_example_class \u2014 Set the class for a specific example type.</p> </li> <li> <p>convert_code_block \u2014 Convert code blocks in the provided text to Markdown format.</p> </li> <li> <p>finditer \u2014 Find all matches of a regex pattern in the provided text.</p> </li> <li> <p>sub \u2014 Substitute all matches of a regex pattern in the provided text.</p> </li> <li> <p>create_admonition \u2014 Create a formatted admonition block for Markdown.</p> </li> </ul> <p> source set_example_class(input_class: str, output_class: str) \u2192 None </p> <p>Set the class for a specific example type.</p> <p>Modify the class attribute of the EXAMPLE_CLASS dictionary to associate a specific example type with a given class name.</p> <p> Parameters </p> <ul> <li> <p>input_class :  str \u2014 The class name to associate with the input of examples.</p> </li> <li> <p>output_class :  str \u2014 The class name to associate with the output of examples.</p> </li> </ul> <p> source convert_code_block(text: str) \u2192 str </p> <p>Convert code blocks in the provided text to Markdown format.</p> <p>Process the input text to identify and convert code blocks into Markdown format. Handle both fenced code blocks and example lists, ensuring they are processed correctly.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The input text containing code blocks to be converted.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The modified text with code blocks converted to Markdown format.</p> </li> </ul> <p> source finditer(pattern: re.Pattern[str], text: str, pos: int = 0, endpos: int | None = None) \u2192 Iterator[re.Match[str]] </p> <p>Find all matches of a regex pattern in the provided text.</p> <p>Search for all occurrences of the specified regex pattern in the provided text. The markdown code blocks are not processed.</p> <p> Parameters </p> <ul> <li> <p>pattern :  re.Pattern \u2014 The compiled regex pattern to search for in the text.</p> </li> <li> <p>text :  str \u2014 The text to search for matches.</p> </li> <li> <p>pos :  int \u2014 The starting position in the text to search for matches.</p> </li> <li> <p>endpos :  int | None \u2014 The ending position in the text to search for matches.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>re.Match \u2014 Each match found in the text.</p> </li> </ul> <p> source sub(pattern: re.Pattern[str], rel: Callable[[re.Match[str]], str], text: str, pos: int = 0, endpos: int | None = None) \u2192 str </p> <p>Substitute all matches of a regex pattern in the provided text.</p> <p>Replace all occurrences of the specified regex pattern in the provided text with the result of the provided callable. The markdown code blocks are not processed.</p> <p> Parameters </p> <ul> <li> <p>pattern :  re.Pattern \u2014 The compiled regex pattern to search for in the text.</p> </li> <li> <p>rel :  Callable[[re.Match], str] \u2014 A callable that takes a match object and returns a string.</p> </li> <li> <p>text :  str \u2014 The text to search for matches and perform substitutions.</p> </li> <li> <p>pos :  int \u2014 The starting position in the text to search for matches.</p> </li> <li> <p>endpos :  int | None \u2014 The ending position in the text to search for matches.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The modified text with all matches of the pattern replaced by the result of the callable.</p> </li> </ul> <p> source create_admonition(name: str, title: str, text: str) \u2192 str </p> <p>Create a formatted admonition block for Markdown.</p> <p>Create a Markdown representation of an admonition, which is a special block used to highlight important information, warnings, or notes, including a title and content.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The type of admonition (e.g., \"note\", \"warning\", \"tip\").</p> </li> <li> <p>title :  str \u2014 The title of the admonition.</p> </li> <li> <p>text :  str \u2014 The content of the admonition.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 A formatted string representing the admonition block in Markdown.</p> </li> </ul> <p> Examples </p> <pre><code>name = \"warning\"\ntitle = \"Caution\"\ntext = \"This is a warning message.\"\nprint(create_admonition(name, title, text))\n</code></pre> <pre><code>!!! warning \"Caution\"\n    This is a warning message.\n</code></pre>"},{"location":"api/astdoc/node/","title":"astdoc.node","text":"astdoc.node<p> source module astdoc.node </p> <p>Node representation module for Abstract Syntax Tree (AST).</p> <p>Provide classes and functions for representing and manipulating nodes in the Abstract Syntax Tree (AST) of Python code. The AST is a tree representation of the abstract syntactic structure of source code, which allows for programmatic analysis and transformation of Python code.</p> <p> Classes </p> <ul> <li> <p>Node \u2014 Represent a generic node in the Abstract Syntax Tree (AST).</p> </li> <li> <p>Import \u2014 Represent an import statement in the Abstract Syntax Tree (AST).</p> </li> <li> <p>Definition \u2014 Represent a definition (e.g., class, function) in the Abstract Syntax Tree (AST).</p> </li> <li> <p>Assign \u2014 Represent an assignment statement in the Abstract Syntax Tree (AST).</p> </li> <li> <p>Module \u2014 Represent a module in the Abstract Syntax Tree (AST).</p> </li> </ul> <p> Functions </p> <ul> <li> <p>iter_child_nodes \u2014 Iterate over the child nodes of the given AST node.</p> </li> <li> <p>extract_import_module_name \u2014 Extract the module name from the given <code>ast.ImportFrom</code> node.</p> </li> <li> <p>get_child_nodes \u2014 Get the child nodes of the given AST node.</p> </li> <li> <p>iter_nodes \u2014 Iterate over the nodes corresponding to the given fully qualified name.</p> </li> <li> <p>parse_node \u2014 Parse the given AST node and return a list of tuples.</p> </li> <li> <p>parse_module \u2014 Parse the given module and return a list of tuples.</p> </li> <li> <p>get_node \u2014 Retrieve a node corresponding to the given name and module.</p> </li> <li> <p>get_module_members \u2014 Get the members of the given module.</p> </li> <li> <p>iter_module_members \u2014 Iterate over the members of the given module.</p> </li> <li> <p>iter_classes_from_module \u2014 Iterate over the classes in the given module.</p> </li> <li> <p>iter_functions_from_module \u2014 Iterate over the functions in the given module.</p> </li> <li> <p>iter_modules_from_module \u2014 Iterate over the modules in the given module.</p> </li> <li> <p>iter_methods_from_class \u2014 Iterate over the methods in the given class.</p> </li> <li> <p>resolve \u2014 Resolve the given name and return a tuple of the name and module.</p> </li> <li> <p>get_fullname_from_module \u2014 Get the fully qualified name of the given name and module.</p> </li> </ul> <p> source dataclass Node(name: str, node: AST) </p> <p>Represent a generic node in the Abstract Syntax Tree (AST).</p> <p>Serve as a base representation for various types of nodes in the AST, encapsulating common attributes and behaviors. Each node is characterized by its name and the corresponding AST node.</p> <p>This class is intended to be subclassed by more specific node types (e.g., <code>Import</code>, <code>Definition</code>, <code>Assign</code>) that require additional attributes or behaviors specific to their context within the AST.</p> <p> Attributes </p> <ul> <li> <p>name :  str \u2014 The name of the node.</p> </li> <li> <p>node :  AST \u2014 The AST node associated with this representation.</p> </li> </ul> <p> source dataclass Import(name: str, node: ast.Import | ast.ImportFrom, fullname: str) </p> <p>Bases : Node</p> <p>Represent an import statement in the Abstract Syntax Tree (AST).</p> <p>Specialized representation of an import statement, which can either be a standard import or an import from a specific module. Inherit from the <code>Node</code> class and includes additional attributes specific to import statements.</p> <p> Attributes </p> <ul> <li> <p>name :  str \u2014 The name of the node.</p> </li> <li> <p>node :  ast.Import | ast.ImportFrom \u2014 The actual AST node associated with this import statement, which can be either an <code>ast.Import</code> or <code>ast.ImportFrom</code> node from the <code>ast</code> module.</p> </li> <li> <p>fullname :  str \u2014 The fully qualified name of the import statement, including the module and any aliases.</p> </li> </ul> <p> source dataclass Definition(name: str, node: ast.ClassDef | ast.FunctionDef | ast.AsyncFunctionDef, module: str) </p> <p>Bases : Node</p> <p>Represent a definition (e.g., class, function) in the Abstract Syntax Tree (AST).</p> <p>Specialized representation of a definition, such as a class or function, within the AST. Inherit from the <code>Node</code> class and includes additional attributes specific to definition representations.</p> <p> Attributes </p> <ul> <li> <p>name :  str \u2014 The name of the node.</p> </li> <li> <p>node :  ast.ClassDef | ast.FunctionDef | ast.AsyncFunctionDef \u2014 The actual AST node associated with this definition, which can be a class definition, a function definition, or an asynchronous function definition from the <code>ast</code> module.</p> </li> <li> <p>module :  str \u2014 The module in which the definition is defined.</p> </li> </ul> <p> source dataclass Assign(name: str, node: ast.AnnAssign | ast.Assign | TypeAlias, module: str) </p> <p>Bases : Node</p> <p>Represent an assignment statement in the Abstract Syntax Tree (AST).</p> <p>Specialized representation of an assignment statement, which can be either an annotated assignment or a simple assignment. Inherit from the <code>Node</code> class and includes additional attributes specific to assignment representations.</p> <p> Attributes </p> <ul> <li> <p>name :  str \u2014 The name of the node.</p> </li> <li> <p>node :  ast.AnnAssign | ast.Assign | TypeAlias \u2014 The actual AST node associated with this assignment statement, which can be an annotated assignment, a simple assignment, or a type alias from the <code>ast</code> module.</p> </li> <li> <p>module :  str \u2014 The module in which the assignment is defined.</p> </li> </ul> <p> source dataclass Module(name: str, node: ast.Module) </p> <p>Bases : Node</p> <p>Represent a module in the Abstract Syntax Tree (AST).</p> <p>Specialized representation of a module within the AST. Inherit from the <code>Node</code> class and includes additional attributes specific to module representations.</p> <p> Attributes </p> <ul> <li> <p>name :  str \u2014 The name of the node.</p> </li> <li> <p>node :  ast.Module \u2014 The actual AST node associated with this module, representing the entire module structure as defined in the Abstract Syntax Tree (AST) from the <code>ast</code> module.</p> </li> </ul> <p> source iter_child_nodes(node: AST, module: str) \u2192 Iterator[Definition | Assign | Import] </p> <p>Iterate over the child nodes of the given AST node.</p> <p>Traverse the Abstract Syntax Tree (AST) and yield child nodes that are instances of <code>Definition</code>, <code>Assign</code>, or <code>Import</code>. Use the <code>astdoc.ast</code> module to iterate over the child nodes of the provided AST node.</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The root AST node to start iteration from.</p> </li> <li> <p>module :  str \u2014 The module in which the node is defined.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Definition | Assign | Import \u2014 The child nodes.</p> </li> </ul> <p> source extract_import_module_name(node: ast.ImportFrom, module: str) \u2192 str </p> <p>Extract the module name from the given <code>ast.ImportFrom</code> node.</p> <p>Retrieve the module name from the specified <code>ast.ImportFrom</code> node. Utilize the <code>ast</code> module to determine the module name based on the node's level and the provided module attributes.</p> <p> Parameters </p> <ul> <li> <p>node :  ast.ImportFrom \u2014 The <code>ast.ImportFrom</code> node to process.</p> </li> <li> <p>module :  str \u2014 The module in which the node is defined.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The module name extracted from the <code>ast.ImportFrom</code> node.</p> </li> </ul> <p> source get_child_nodes(node: AST, module: str) \u2192 list[Definition | Assign | Import] </p> <p>Get the child nodes of the given AST node.</p> <p>Traverse the Abstract Syntax Tree (AST) and collect child nodes of the given root node. Use the <code>iter_child_nodes</code> function to iterate over the child nodes of the provided AST node.</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The root AST node to start iteration from.</p> </li> <li> <p>module :  str \u2014 The module in which the node is defined.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[Definition | Assign | Import] \u2014 A list of the child nodes.</p> </li> </ul> <p> source iter_nodes(fullname: str) \u2192 Iterator[Module | Definition | Assign | Import] </p> <p>Iterate over the nodes corresponding to the given fully qualified name.</p> <p>Traverse the Abstract Syntax Tree (AST) corresponding to the given fullname and yield instances of <code>Module</code>, <code>Definition</code>, <code>Assign</code>, or <code>Import</code>.</p> <p> Parameters </p> <ul> <li> <p>fullname :  str \u2014 The fully qualified name of the module or object.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Module | Definition | Assign | Import \u2014 The node instances.</p> </li> </ul> <p> source parse_node(node: AST, module: str) \u2192 list[tuple[str, Module | Definition | Assign | Import]] </p> <p>Parse the given AST node and return a list of tuples.</p> <p>Traverse the Abstract Syntax Tree (AST) and return a list of tuples containing the name and the corresponding node.</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The root AST node to start iteration from.</p> </li> <li> <p>module :  str \u2014 The module in which the node is defined.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[tuple[str, Module | Definition | Assign | Import]] \u2014 A list of tuples containing the name and the corresponding node instance.</p> </li> </ul> <p> source parse_module(module: str) \u2192 list[tuple[str, Module | Definition | Assign | Import]] </p> <p>Parse the given module and return a list of tuples.</p> <p>Parse the given module and return a list of tuples containing the name and the corresponding node instance.</p> <p> Parameters </p> <ul> <li> <p>module :  str \u2014 The name of the module to parse.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[tuple[str, Module | Definition | Assign | Import]] \u2014 A list of tuples containing the name and the corresponding node.</p> </li> </ul> <p> source get_node(name: str, module: str | None = None) \u2192 Module | Definition | Assign | Import | None </p> <p>Retrieve a node corresponding to the given name and module.</p> <p>Searche for a node in the Abstract Syntax Tree (AST) based on the provided name and optional module. Return the corresponding node instance if found, or None if not.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the node to retrieve.</p> </li> <li> <p>module :  str | None \u2014 The module in which the node is defined. If None, a module name will be extracted from the name.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Module | Definition | Assign | Import | None \u2014 The node instance corresponding to the given name and module, or None if not found.</p> </li> </ul> <p> source get_module_members(module: str, private: bool = False, special: bool = False, *, child_only: bool = False) \u2192 list[tuple[str, Module | Definition]] </p> <p>Get the members of the given module.</p> <p>Traverse the Abstract Syntax Tree (AST) and return the names and objects of the members of the given module. If <code>__all__</code> is defined, the members are sorted by the order of the names in <code>__all__</code>.</p> <p> Parameters </p> <ul> <li> <p>module :  str \u2014 The name of the module to iterate over.</p> </li> <li> <p>private :  bool \u2014 Whether to include private members.</p> </li> <li> <p>special :  bool \u2014 Whether to include special members.</p> </li> <li> <p>child_only :  bool \u2014 Whether to include only the child nodes.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[tuple[str, Module | Definition]] \u2014 The names and objects of the members of the given module.</p> </li> </ul> <p> source iter_module_members(module: str, private: bool = False, special: bool = False, *, child_only: bool = False) \u2192 Iterator[tuple[str, Module | Definition]] </p> <p>Iterate over the members of the given module.</p> <p>Traverse the Abstract Syntax Tree (AST) and yield the names and objects of the members of the given module.</p> <p> Parameters </p> <ul> <li> <p>module :  str \u2014 The name of the module to iterate over.</p> </li> <li> <p>private :  bool \u2014 Whether to include private members.</p> </li> <li> <p>special :  bool \u2014 Whether to include special members.</p> </li> <li> <p>child_only :  bool \u2014 Whether to include only the child nodes.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>tuple[str, Module | Definition] \u2014 The names and objects of the members of the given module.</p> </li> </ul> <p> source iter_classes_from_module(module: str, private: bool = False, special: bool = False) \u2192 Iterator[str] </p> <p>Iterate over the classes in the given module.</p> <p>Traverse the Abstract Syntax Tree (AST) and yield the names of the classes in the given module.</p> <p> Parameters </p> <ul> <li> <p>module :  str \u2014 The name of the module to iterate over.</p> </li> <li> <p>private :  bool \u2014 Whether to include private members.</p> </li> <li> <p>special :  bool \u2014 Whether to include special members.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>str \u2014 The names of the classes in the given module.</p> </li> </ul> <p> source iter_functions_from_module(module: str, private: bool = False, special: bool = False) \u2192 Iterator[str] </p> <p>Iterate over the functions in the given module.</p> <p>Traverse the Abstract Syntax Tree (AST) and yield the names of the functions in the given module.</p> <p> Parameters </p> <ul> <li> <p>module :  str \u2014 The name of the module to iterate over.</p> </li> <li> <p>private :  bool \u2014 Whether to include private members.</p> </li> <li> <p>special :  bool \u2014 Whether to include special members.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>str \u2014 The names of the functions in the given module.</p> </li> </ul> <p> source iter_modules_from_module(module: str, private: bool = False, special: bool = False) \u2192 Iterator[str] </p> <p>Iterate over the modules in the given module.</p> <p>Traverse the Abstract Syntax Tree (AST) and yield the names of the modules in the given module.</p> <p> Parameters </p> <ul> <li> <p>module :  str \u2014 The name of the module to iterate over.</p> </li> <li> <p>private :  bool \u2014 Whether to include private members.</p> </li> <li> <p>special :  bool \u2014 Whether to include special members.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>str \u2014 The names of the modules in the given module.</p> </li> </ul> <p> source iter_methods_from_class(name: str, module: str, private: bool = False, special: bool = False) \u2192 Iterator[str] </p> <p>Iterate over the methods in the given class.</p> <p>Traverse the Abstract Syntax Tree (AST) and yield the names of the methods in the given class.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the class to iterate over.</p> </li> <li> <p>module :  str \u2014 The name of the module to iterate over.</p> </li> <li> <p>private :  bool \u2014 Whether to include private members.</p> </li> <li> <p>special :  bool \u2014 Whether to include special members.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>str \u2014 The names of the methods in the given class.</p> </li> </ul> <p> source resolve(name: str, module: str | None = None) \u2192 tuple[str | None, str | None] | None </p> <p>Resolve the given name and return a tuple of the name and module.</p> <p>Resolve the given name and return a tuple containing the name and module. Use the <code>get_module_node</code> function to get the module node and the <code>parse_node</code> function to iterate over the nodes in the given fullname.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name to resolve.</p> </li> <li> <p>module :  str | None \u2014 The module in which the name is defined. If None, a module name will be extracted from the name.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>tuple[str | None, str | None] | None \u2014 A tuple containing the name and module, or None if the name could not be resolved.</p> </li> </ul> <p> source get_fullname_from_module(name: str, module: str | None = None) \u2192 str | None </p> <p>Get the fully qualified name of the given name and module.</p> <p>Resolve the given name and return a tuple containing the name and module. Use the <code>resolve</code> function to resolve the given name and module.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name to get the fully qualified name of.</p> </li> <li> <p>module :  str | None \u2014 The module in which the name is defined. If None, a module name will be extracted from the name.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str | None \u2014 The fully qualified name of the given name and module, or None if the name could not be resolved.</p> </li> </ul>"},{"location":"api/astdoc/object/","title":"astdoc.object","text":"astdoc.object<p> source module astdoc.object </p> <p>Handle objects in the Abstract Syntax Tree (AST).</p> <p>Provide classes and functions for representing and manipulating various types of objects within the Abstract Syntax Tree (AST) of Python code. Include representations for modules, classes, functions, attributes, and properties, allowing for detailed analysis and processing of Python code structures.</p> <p> Classes </p> <ul> <li> <p>Object \u2014 Represents a generic object in the Abstract Syntax Tree (AST).</p> </li> <li> <p>Type \u2014 Represents a type in the Abstract Syntax Tree (AST).</p> </li> <li> <p>Attribute \u2014 Represent an attribute in the Abstract Syntax Tree (AST).</p> </li> <li> <p>Property \u2014 Represent a property in the Abstract Syntax Tree (AST).</p> </li> <li> <p>Parent \u2014 Represent a parent node in the Abstract Syntax Tree (AST).</p> </li> <li> <p>Definition \u2014 Represent a definition in the Abstract Syntax Tree (AST).</p> </li> <li> <p>Class \u2014 Represent a class definition in the Abstract Syntax Tree (AST).</p> </li> <li> <p>Function \u2014 Represent a function definition in the Abstract Syntax Tree (AST).</p> </li> <li> <p>Module \u2014 Represent a module in the Abstract Syntax Tree (AST).</p> </li> </ul> <p> Functions </p> <ul> <li> <p>iter_child_objects \u2014 Iterate over child objects of a given AST node.</p> </li> <li> <p>create_attribute \u2014 Create an <code>Attribute</code> object from the given parameters.</p> </li> <li> <p>create_property \u2014 Create a Property object from the given parameters.</p> </li> <li> <p>iter_objects \u2014 Iterate over the child objects of the given object.</p> </li> <li> <p>create_class \u2014 Create a <code>Class</code> object from the given parameters.</p> </li> <li> <p>create_class_by_name \u2014 Create a <code>Class</code> object from the given parameters.</p> </li> <li> <p>get_base_classes \u2014 Get the base classes of a class.</p> </li> <li> <p>iter_attributes_from_function \u2014 Iterate over attributes from a function.</p> </li> <li> <p>iter_parameters_from_dataclass \u2014 Iterate over parameters from a dataclass.</p> </li> <li> <p>create_function \u2014 Create a <code>Function</code> instance from the given parameters.</p> </li> <li> <p>create_module \u2014 Create a <code>Module</code> instance from the given parameters.</p> </li> <li> <p>get_object_kind \u2014 Return the kind of the given object.</p> </li> <li> <p>get_source \u2014 Return the source code of an object.</p> </li> <li> <p>is_child \u2014 Return True if <code>obj</code> is a child of <code>parent</code>.</p> </li> <li> <p>get_object \u2014 Retrieve an object by its name and optional module.</p> </li> <li> <p>get_fullname_from_object \u2014 Return the fully qualified name for <code>name</code> relative to the given <code>Object</code>.</p> </li> </ul> <p> source dataclass Object(name: str, node: AST, module: str, parent: Parent | None) </p> <p>Represents a generic object in the Abstract Syntax Tree (AST).</p> <p>Serve as a base representation for various types of objects in the AST, encapsulating common attributes and behaviors. Each object is characterized by its name, the corresponding AST node, the module it belongs to, its parent object, and its fully qualified name.</p> <p> Attributes </p> <ul> <li> <p>name :  str \u2014 The name of the object, typically representing the identifier in the source code.</p> </li> <li> <p>node :  AST \u2014 The actual AST node associated with this object, providing access to the underlying structure of the code.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the object is defined.</p> </li> <li> <p>parent :  Parent | None \u2014 The parent object of this object, if any.</p> </li> <li> <p>qualname :  str \u2014 The qualified name of the object, combining the parent's qualified name and its name.</p> </li> <li> <p>fullname :  str \u2014 The fully qualified name of the object, which may include module or package information, allowing for unique identification within the codebase.</p> </li> <li> <p>doc :  Doc \u2014 The <code>Doc</code> instance of documentation associated with the object, extracted from the AST node or the object's docstring.</p> </li> <li> <p>kind :  str \u2014 The kind of the object.</p> </li> </ul> <p> source property Object.kind: str </p> <p>The kind of the object.</p> <p> source iter_child_objects(node: AST, module: str, parent: Parent | None) \u2192 Iterator[Object] </p> <p>Iterate over child objects of a given AST node.</p> <p>Traverse the child nodes of the specified Abstract Syntax Tree (AST) node and yield instances of <code>Object</code> for each recognized child node type. Identify classes, functions, properties, and attributes within the AST structure, allowing for easy access to the components of the code.</p> <p> Parameters </p> <ul> <li> <p>node :  AST \u2014 The AST node from which to iterate child objects.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the node is defined.</p> </li> <li> <p>parent :  Parent | None \u2014 The parent object of the current node, if applicable. This is used to maintain the hierarchy of objects.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Object \u2014 The instances of <code>Object</code> representing each recognized child node, such as a class, function, property, or attribute.</p> </li> </ul> <p> source dataclass Type(name: str, node: AST, module: str, parent: Parent | None, type: ast.expr | None) </p> <p>Bases : Object</p> <p>Represents a type in the Abstract Syntax Tree (AST).</p> <p>Specialized representation of a type, which can be associated with variables, function parameters, and other constructs in Python code. Inherit from the <code>Object</code> class and includes additional attributes specific to type information.</p> <p> Attributes </p> <ul> <li> <p>type :  ast.expr | None \u2014 The AST expression representing the type, or None if the type is not specified. This can include type annotations, type hints, or other expressions that define the type of an object.</p> </li> <li> <p>name :  str \u2014 The name of the object.</p> </li> <li> <p>node :  AST \u2014 The AST node associated with this object.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the object is defined.</p> </li> <li> <p>parent :  Parent | None \u2014 The parent object of this object, if any.</p> </li> <li> <p>qualname :  str \u2014 The qualified name of the object.</p> </li> <li> <p>fullname :  str \u2014 The fully qualified name of the object.</p> </li> <li> <p>doc :  Doc \u2014 The documentation associated with the object.</p> </li> <li> <p>kind :  str \u2014 The kind of the object.</p> </li> </ul> <p> source dataclass Attribute(name: str, node: ast.AnnAssign | ast.Assign | TypeAlias, module: str, parent: Parent | None, type: ast.expr | None, default: ast.expr | None) </p> <p>Bases : Type</p> <p>Represent an attribute in the Abstract Syntax Tree (AST).</p> <p>Specialized representation of an attribute. Inherit from the <code>Type</code> class and includes additional attributes specific to attribute information.</p> <p> Attributes </p> <ul> <li> <p>name :  str \u2014 The name of the attribute.</p> </li> <li> <p>node :  ast.AnnAssign | ast.Assign | TypeAlias \u2014 The AST node associated with this attribute.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the attribute is defined.</p> </li> <li> <p>parent :  Parent | None \u2014 The parent object of this attribute, if any.</p> </li> <li> <p>type :  ast.expr | None \u2014 The AST expression representing the type, or None if the type is not specified.</p> </li> <li> <p>default :  ast.expr | None \u2014 The default value of the attribute, if any.</p> </li> <li> <p>qualname :  str \u2014 The qualified name of the object.</p> </li> <li> <p>fullname :  str \u2014 The fully qualified name of the object.</p> </li> <li> <p>doc :  Doc \u2014 The documentation associated with the object.</p> </li> <li> <p>kind :  str \u2014 The kind of the object.</p> </li> </ul> <p> source dataclass Property(name: str, node: ast.FunctionDef | ast.AsyncFunctionDef, module: str, parent: Parent | None, type: ast.expr | None) </p> <p>Bases : Type</p> <p>Represent a property in the Abstract Syntax Tree (AST).</p> <p>Specialized representation of a property. Inherit from the <code>Type</code> class and includes additional attributes specific to property information.</p> <p> Attributes </p> <ul> <li> <p>name :  str \u2014 The name of the property.</p> </li> <li> <p>node :  ast.FunctionDef | ast.AsyncFunctionDef \u2014 The AST node associated with this property.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the property is defined.</p> </li> <li> <p>parent :  Parent | None \u2014 The parent object of this property, if any.</p> </li> <li> <p>type :  ast.expr | None \u2014 The AST expression representing the type, or None if the type is not specified.</p> </li> <li> <p>qualname :  str \u2014 The qualified name of the object.</p> </li> <li> <p>fullname :  str \u2014 The fully qualified name of the object.</p> </li> <li> <p>doc :  Doc \u2014 The documentation associated with the object.</p> </li> <li> <p>kind :  str \u2014 The kind of the object.</p> </li> </ul> <p> source create_attribute(name: str, node: ast.AnnAssign | ast.Assign | TypeAlias, module: str, parent: Parent | None) \u2192 Attribute </p> <p>Create an <code>Attribute</code> object from the given parameters.</p> <p>Construct an instance of the <code>Attribute</code> class, which represents an attribute in the Abstract Syntax Tree (AST). Extract relevant information from the provided AST node and associate it with the attribute.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the attribute.</p> </li> <li> <p>node :  ast.AnnAssign | ast.Assign | TypeAlias \u2014 The AST node associated with this attribute.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the attribute is defined.</p> </li> <li> <p>parent :  Parent | None \u2014 The parent object of this attribute, if any.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Attribute \u2014 An instance of the <code>Attribute</code> class representing the specified attribute, including its name, node, module, parent, and any associated type information.</p> </li> </ul> <p> source create_property(node: ast.FunctionDef | ast.AsyncFunctionDef, module: str, parent: Parent | None) \u2192 Property </p> <p>Create a Property object from the given parameters.</p> <p>Construct an instance of the <code>Property</code> class, which represents a property in the Abstract Syntax Tree (AST). Extract relevant information from the provided AST node and associate it with the property.</p> <p> Parameters </p> <ul> <li> <p>node :  ast.FunctionDef | ast.AsyncFunctionDef \u2014 The AST node associated with this property.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the property is defined.</p> </li> <li> <p>parent :  Parent | None \u2014 The parent object of this property, if any.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Property \u2014 An instance of the <code>Property</code> class representing the specified property, including its name, node, module, parent, and any associated type information.</p> </li> </ul> <p> source dataclass Parent(name: str, node: AST, module: str, parent: Parent | None) </p> <p>Bases : Object</p> <p>Represent a parent node in the Abstract Syntax Tree (AST).</p> <p>Specialized subclass of the <code>Object</code> class that manages child objects, allowing for hierarchical relationships between objects in the AST structure. Provide methods to retrieve child objects by name or type, facilitating the organization and manipulation of AST nodes.</p> <p> Attributes </p> <ul> <li> <p>children :  dict[str, Object] \u2014 A dictionary that stores child objects, where the keys are the names of the children and the values are instances of <code>Object</code>.</p> </li> <li> <p>name :  str \u2014 The name of the object.</p> </li> <li> <p>node :  AST \u2014 The AST node associated with this object.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the object is defined.</p> </li> <li> <p>parent :  Parent | None \u2014 The parent object of this object, if any.</p> </li> <li> <p>qualname :  str \u2014 The qualified name of the object.</p> </li> <li> <p>fullname :  str \u2014 The fully qualified name of the object.</p> </li> <li> <p>doc :  Doc \u2014 The documentation associated with the object.</p> </li> <li> <p>kind :  str \u2014 The kind of the object.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>get \u2014 Retrieve a child object by name, ensuring it is of the specified type.</p> </li> <li> <p>get_children \u2014 Retrieve a list of the child objects of the specified type.</p> </li> </ul> <p> source method Parent.get(name: str, type_: type[T] = Object) \u2192 T | None </p> <p>Retrieve a child object by name, ensuring it is of the specified type.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the child object to retrieve.</p> </li> <li> <p>type_ :  type[T] \u2014 The type of the child object to ensure.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>T | None \u2014 The child object if found and of the specified type, otherwise None.</p> </li> </ul> <p> source method Parent.get_children(type_: type[T] = Object) \u2192 list[tuple[str, T]] </p> <p>Retrieve a list of the child objects of the specified type.</p> <p> Parameters </p> <ul> <li> <p>type_ :  type[T] \u2014 The type of the child objects to retrieve.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[tuple[str, T]] \u2014 A list of tuples, where each tuple contains the name and the child object, ensuring the object is of the specified type.</p> </li> </ul> <p> source iter_objects(obj: Object, type_: type[T] = Object) \u2192 Iterator[T] </p> <p>Iterate over the child objects of the given object.</p> <p>Recursively traverse the children of the provided object and yields objects that match the specified type.</p> <p> Parameters </p> <ul> <li> <p>obj :  Object \u2014 The object whose children are to be iterated over.</p> </li> <li> <p>type_ :  type[T] \u2014 The type of the child objects to ensure.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>T \u2014 The objects that are children of the object and matches the specified type.</p> </li> </ul> <p> source dataclass Definition(name: str, node: AST, module: str, parent: Parent | None, parameters: list[Parameter], raises: list[ast.expr]) </p> <p>Bases : Parent</p> <p>Represent a definition in the Abstract Syntax Tree (AST).</p> <p>Specialized representation of a definition, such as a class or function, within the AST. Inherit from the <code>Parent</code> class and includes additional attributes specific to definitions, such as parameters and exceptions that may be raised.</p> <p> Attributes </p> <ul> <li> <p>parameters :  list[Parameter] \u2014 A list of parameters associated with the definition, representing the input values for functions or methods.</p> </li> <li> <p>raises :  list[ast.expr] \u2014 A list of expressions representing the exceptions that may be raised by the definition.</p> </li> <li> <p>name :  str \u2014 The name of the object.</p> </li> <li> <p>node :  AST \u2014 The AST node associated with this object.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the object is defined.</p> </li> <li> <p>parent :  Parent | None \u2014 The parent object of this object, if any.</p> </li> <li> <p>qualname :  str \u2014 The qualified name of the object.</p> </li> <li> <p>fullname :  str \u2014 The fully qualified name of the object.</p> </li> <li> <p>doc :  Doc \u2014 The documentation associated with the object.</p> </li> <li> <p>kind :  str \u2014 The kind of the object.</p> </li> <li> <p>children :  dict[str, Object] \u2014 A dictionary that stores child objects, where the keys are the names of the children and the values are instances of <code>Object</code>.</p> </li> </ul> <p> source dataclass Class(name: str, node: ast.ClassDef, module: str, parent: Parent | None, parameters: list[Parameter], raises: list[ast.expr]) </p> <p>Bases : Definition</p> <p>Represent a class definition in the Abstract Syntax Tree (AST).</p> <p>Specialized representation of a class within the AST. Inherit from the <code>Definition</code> class and includes additional attributes specific to class definitions.</p> <p> Attributes </p> <ul> <li> <p>node :  ast.ClassDef \u2014 The actual AST node associated with this class definition, which contains the structure and properties of the class as defined in the source code.</p> </li> <li> <p>name :  str \u2014 The name of the object.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the object is defined.</p> </li> <li> <p>parent :  Parent | None \u2014 The parent object of this object, if any.</p> </li> <li> <p>qualname :  str \u2014 The qualified name of the object.</p> </li> <li> <p>fullname :  str \u2014 The fully qualified name of the object.</p> </li> <li> <p>doc :  Doc \u2014 The documentation associated with the object.</p> </li> <li> <p>kind :  str \u2014 The kind of the object.</p> </li> <li> <p>children :  dict[str, Object] \u2014 A dictionary that stores child objects, where the keys are the names of the children and the values are instances of <code>Object</code>.</p> </li> <li> <p>parameters :  list[Parameter] \u2014 A list of parameters associated with the definition, representing the input values for functions or methods.</p> </li> <li> <p>raises :  list[ast.expr] \u2014 A list of expressions representing the exceptions that may be raised by the definition.</p> </li> </ul> <p> source dataclass Function(name: str, node: ast.FunctionDef | ast.AsyncFunctionDef, module: str, parent: Parent | None, parameters: list[Parameter], raises: list[ast.expr]) </p> <p>Bases : Definition</p> <p>Represent a function definition in the Abstract Syntax Tree (AST).</p> <p>Specialized representation of a function within the AST. Inherit from the <code>Definition</code> class and includes additional attributes specific to function definitions.</p> <p> Attributes </p> <ul> <li> <p>node :  ast.FunctionDef | ast.AsyncFunctionDef \u2014 The actual AST node associated with this function definition, which contains the structure and properties of the function as defined in the source code.</p> </li> <li> <p>name :  str \u2014 The name of the object.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the object is defined.</p> </li> <li> <p>parent :  Parent | None \u2014 The parent object of this object, if any.</p> </li> <li> <p>qualname :  str \u2014 The qualified name of the object.</p> </li> <li> <p>fullname :  str \u2014 The fully qualified name of the object.</p> </li> <li> <p>doc :  Doc \u2014 The documentation associated with the object.</p> </li> <li> <p>kind :  str \u2014 The kind of the object.</p> </li> <li> <p>children :  dict[str, Object] \u2014 A dictionary that stores child objects, where the keys are the names of the children and the values are instances of <code>Object</code>.</p> </li> <li> <p>parameters :  list[Parameter] \u2014 A list of parameters associated with the definition, representing the input values for functions or methods.</p> </li> <li> <p>raises :  list[ast.expr] \u2014 A list of expressions representing the exceptions that may be raised by the definition.</p> </li> </ul> <p> source create_class(node: ast.ClassDef, module: str, parent: Parent | None) \u2192 Class </p> <p>Create a <code>Class</code> object from the given parameters.</p> <p>Construct an instance of the <code>Class</code> class, which represents a class definition in the Abstract Syntax Tree (AST). Extract relevant information from the provided AST node and associates it with the class.</p> <p> Parameters </p> <ul> <li> <p>node :  ast.ClassDef \u2014 The AST node associated with this class definition.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the class is defined.</p> </li> <li> <p>parent :  Parent | None \u2014 The parent object of this class, if any.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Class \u2014 An instance of the <code>Class</code> class representing the specified class, including its name, node, module, parent, and any associated attributes.</p> </li> </ul> <p> source create_class_by_name(name: str, module: str, parent: Parent | None) \u2192 Class | None </p> <p>Create a <code>Class</code> object from the given parameters.</p> <p>Construct an instance of the <code>Class</code> class representing a class definition in the Abstract Syntax Tree (AST). Extract relevant information from the provided AST node and associate it with the class.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the class to create.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the class is defined.</p> </li> <li> <p>parent :  Parent | None \u2014 The <code>Parent</code> object of this class, if any.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Class | None \u2014 An instance of the <code>Class</code> class representing the specified class, including its name, node, module, parent, and any associated attributes, or None if the class cannot be created.</p> </li> </ul> <p> source get_base_classes(name: str, module: str) \u2192 list[Class] </p> <p>Get the base classes of a class.</p> <p>Retrieve the base classes of a class by searching for the class definition in the module and its base classes. Use the <code>get_base_classes</code> utility function to get the base class names and modules, and then retrieve the corresponding <code>Class</code> objects from the cached <code>objects</code> dictionary.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the class to get the base classes for.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the class is defined.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[Class] \u2014 A list of the <code>Class</code> instances representing the base classes of the specified class.</p> </li> </ul> <p> source iter_attributes_from_function(func: Function, parent: Parent) \u2192 Iterator[Attribute] </p> <p>Iterate over attributes from a function.</p> <p>Iterate over the attributes of a function, creating <code>Attribute</code> objects for each attribute found. Use the <code>get_children</code> method to retrieve the attributes and ensure that the attributes are associated with the correct parent object.</p> <p> Parameters </p> <ul> <li> <p>func :  Function \u2014 The function object containing the attributes.</p> </li> <li> <p>parent :  Parent \u2014 The parent object to which the attributes belong.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Attribute \u2014 <code>Attribute</code> instances of the function.</p> </li> </ul> <p> source iter_parameters_from_dataclass(cls: Class) \u2192 Iterator[Parameter] </p> <p>Iterate over parameters from a dataclass.</p> <p>This function iterates over the parameters of a dataclass, creating Parameter objects for each parameter found. It uses the <code>get_children</code> method to retrieve the parameters and ensures that the parameters are associated with the correct parent object.</p> <p> Parameters </p> <ul> <li> <p>cls :  Class \u2014 The dataclass object containing the parameters.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Parameter \u2014 <code>Parameter</code> instances of the dataclass.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>NotImplementedError</p> </li> </ul> <p> source create_function(node: ast.FunctionDef | ast.AsyncFunctionDef, module: str, parent: Parent | None) \u2192 Function </p> <p>Create a <code>Function</code> instance from the given parameters.</p> <p>Construct an instance of the <code>Function</code> class, which represents a function definition in the Abstract Syntax Tree (AST). Extract relevant information from the provided AST node and associates it with the function.</p> <p> Parameters </p> <ul> <li> <p>node :  ast.FunctionDef | ast.AsyncFunctionDef \u2014 The AST node associated with this function definition, which contains the structure and properties of the function as defined in the source code.</p> </li> <li> <p>module :  str \u2014 The name of the module in which the function is defined.</p> </li> <li> <p>parent :  Parent | None \u2014 The parent object of this function, if any.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Function \u2014 An instance of the <code>Function</code> class representing the specified function, including its name, node, module, parent, and any associated attributes.</p> </li> </ul> <p> source dataclass Module(name: str, node: ast.Module) </p> <p>Bases : Parent</p> <p>Represent a module in the Abstract Syntax Tree (AST).</p> <p>Specialized representation of a module within the AST, inheriting from the <code>Parent</code> class. Encapsulate the structure and properties of a Python module, including its child objects, which can be classes, functions, and other attributes defined within the module.</p> <p> Attributes </p> <ul> <li> <p>node :  ast.Module \u2014 The actual AST node associated with this module.</p> </li> <li> <p>module :  None \u2014 A placeholder for the module name, initialized to None.</p> </li> <li> <p>parent :  None \u2014 A placeholder for the parent object, initialized to None.</p> </li> <li> <p>name :  str \u2014 The name of the object.</p> </li> <li> <p>qualname :  str \u2014 The qualified name of the object.</p> </li> <li> <p>fullname :  str \u2014 The fully qualified name of the object.</p> </li> <li> <p>doc :  Doc \u2014 The documentation associated with the object.</p> </li> <li> <p>kind :  str \u2014 The kind of the object.</p> </li> <li> <p>children :  dict[str, Object] \u2014 A dictionary that stores child objects, where the keys are the names of the children and the values are instances of <code>Object</code>.</p> </li> </ul> <p> source create_module(name: str, node: ast.Module | None = None, source: str | None = None) \u2192 Module | None </p> <p>Create a <code>Module</code> instance from the given parameters.</p> <p>Construct an instance of the <code>Module</code> class, which represents a module in the Abstract Syntax Tree (AST). Extract relevant information from the provided AST node and associates it with the module.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the module to create.</p> </li> <li> <p>node :  ast.Module | None \u2014 The AST node associated with this module. If None, the function attempts to retrieve the node from the module name.</p> </li> <li> <p>source :  str | None \u2014 The source code of the module as a string. If provided, it is used to extract documentation comments for attributes within the module.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Module | None \u2014 An instance of the <code>Module</code> class representing the specified module, including its name, node, and any associated attributes. Returns None if the module cannot be created.</p> </li> </ul> <p> source get_object_kind(obj: Object) \u2192 str </p> <p>Return the kind of the given object.</p> <p>Determine the kind of the provided object and return a string representation of its kind. The function checks the specific type of the object and returns a corresponding label.</p> <p> Parameters </p> <ul> <li> <p>obj :  Object \u2014 The object whose kind is to be determined.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 A string representing the kind of the object. Possible return values include:</p> <ul> <li>package, module</li> <li>class, dataclass, enum</li> <li>function, method, classmethod, staticmethod</li> <li>property</li> </ul> </li> </ul> <p> source get_source(obj: Object) \u2192 str | None </p> <p>Return the source code of an object.</p> <p>Retrieve the source code associated with the given object, which can be a <code>Module</code> or any other object that has a corresponding Abstract Syntax Tree (AST) node. Check the type of the object and use appropriate methods to obtain the source code.</p> <p> Parameters </p> <ul> <li> <p>obj :  Object \u2014 The object whose source code is to be retrieved. This can be an instance of Module or any other object with an AST node.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str | None \u2014 The source code of the object as a string if available, or None if the source code cannot be retrieved.</p> </li> </ul> <p> source is_child(obj: Object, parent: Object | None) \u2192 bool </p> <p>Return True if <code>obj</code> is a child of <code>parent</code>.</p> <p>Check if the given object (<code>obj</code>) is a child of the specified parent object. Compare the parent attribute of the object and the provided parent argument.</p> <p> Parameters </p> <ul> <li> <p>obj :  Object \u2014 The object to check if it is a child.</p> </li> <li> <p>parent :  Object | None \u2014 The parent object to compare against.</p> </li> </ul> <p> source get_object(name: str, module: str | None = None) \u2192 Object | None </p> <p>Retrieve an object by its name and optional module.</p> <p>Attempt to find and return an object based on the provided name and module. First construct the full name of the object and check if it exists in the cached objects. If the object is not found, attempt to split the full name into its component parts and create the module if necessary. The function will attempt to create a <code>Module</code> instance based on the object's name.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the object to retrieve.</p> </li> <li> <p>module :  str | None \u2014 The name of the module in which the object is defined. If None, a module name will be extracted from the name.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Object | None \u2014 The <code>Object</code> instance corresponding to the specified name and module, or None if the object cannot be found or created.</p> </li> </ul> <p> source get_fullname_from_object(name: str, obj: Object) \u2192 str | None </p> <p>Return the fully qualified name for <code>name</code> relative to the given <code>Object</code>.</p> <p>Construct the fully qualified name for <code>name</code> based on the context of the provided <code>Object</code> instance. Check the type of the object and resolve the fullname accordingly.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name for which to retrieve the full name.</p> </li> <li> <p>obj :  Object \u2014 The object instance that provides context for the name.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str | None \u2014 The fully qualified name of the specified name relative to the object, or None if the fullname cannot be determined.</p> </li> </ul>"},{"location":"api/astdoc/utils/","title":"astdoc.utils","text":"astdoc.utils<p> source module astdoc.utils </p> <p>Utility functions for the application.</p> <p>Contain a collection of utility functions that provide various helper functionalities for the application. These functions are designed to be reusable and facilitate common tasks such as module introspection, caching, and object retrieval.</p> <p> Functions </p> <ul> <li> <p>cache \u2014 Cache a function or data structure and register it for cache clearing.</p> </li> <li> <p>cache_clear \u2014 Clear the cache of all cached objects.</p> </li> <li> <p>get_module_path \u2014 Return the source path of the specified module name.</p> </li> <li> <p>get_module_name \u2014 Return the name of the specified module.</p> </li> <li> <p>is_package \u2014 Return True if the specified name is a package.</p> </li> <li> <p>iter_submodule_names \u2014 Yield the names of submodules for the specified module.</p> </li> <li> <p>find_submodule_names \u2014 Return a list of submodule names.</p> </li> <li> <p>get_module_node_source \u2014 Return the AST node and source code of the specified module.</p> </li> <li> <p>get_module_node \u2014 Return the AST node of the specified module.</p> </li> <li> <p>get_module_source \u2014 Return the source code of the specified module.</p> </li> <li> <p>iter_attribute_names \u2014 Yield parent module names in a dot-separated format.</p> </li> <li> <p>iter_by_name \u2014 Yield items from the iterable that match the specified name.</p> </li> <li> <p>find_item_by_name \u2014 Find the first item with a specified name from an iterable of items.</p> </li> <li> <p>find_item_by_kind \u2014 Find the first item of a specified kind from an iterable of items.</p> </li> <li> <p>find_item_by_type \u2014 Find the first item of a specified type from an iterable of items.</p> </li> <li> <p>delete_item_by_name \u2014 Delete the first item with a specified name from a list of items.</p> </li> <li> <p>merge_unique_names \u2014 Merge two iterables and return a list of unique names.</p> </li> <li> <p>split_filters \u2014 Split filters written after <code>|</code> in a given string.</p> </li> <li> <p>update_filters \u2014 Update filters by merging and resolving conflicts.</p> </li> <li> <p>is_identifier \u2014 Return True if the name is a valid identifier, considering dot-separated parts.</p> </li> <li> <p>iter_identifiers \u2014 Yield identifiers and their validity from the given source string.</p> </li> <li> <p>list_exported_names \u2014 Retrieve the list of exported names from a specified module.</p> </li> <li> <p>get_object_from_module \u2014 Retrieve an object from a specified module by its name.</p> </li> <li> <p>is_dataclass \u2014 Check if the specified object is a dataclass.</p> </li> <li> <p>is_enum \u2014 Check if the specified object is an enum.</p> </li> <li> <p>get_base_classes \u2014 Retrieve the base classes of a specified class from a module.</p> </li> <li> <p>split_module_name \u2014 Split a dot-separated name into a module name and the remaining part.</p> </li> </ul> <p> source cache(obj: Callable[..., T] | dict | list) \u2192 Callable[..., T] | dict | list </p> <p>Cache a function or data structure and register it for cache clearing.</p> <p>Accept a callable (function) or a data structure (dictionary or list) and caches it. If a callable is provided, it wraps it with a caching mechanism and stores it in a global list of cached objects. If a dictionary or list is provided, it is simply added to the cache list.</p> <p> Parameters </p> <ul> <li> <p>obj :  Callable[..., T] | dict | list \u2014 The object to cache, which can be a callable function, a dictionary, or a list.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Callable[..., T] | dict | list \u2014 The cached object, which is either the cached function or the original dictionary/list.</p> </li> </ul> <p> Examples </p> <pre><code>@cache\ndef my_function(x):\n    return x * 2\ncached_function = cache(my_function)\ncached_function(5)\n</code></pre> <pre><code>10\n</code></pre> <pre><code>my_dict = {'key': 'value'}\ncached_dict = cache(my_dict)\ncached_dict['key']\n</code></pre> <pre><code>'value'\n</code></pre> <p> source cache_clear() \u2192 None </p> <p>Clear the cache of all cached objects.</p> <p>Iterate through the global list of cached objects and clear the cache for each object. If the object is callable (a function), call its <code>cache_clear</code> method. If the object is a dictionary or list, clear its contents.</p> <p> Returns </p> <ul> <li> <p>None \u2014 This function does not return any value.</p> </li> </ul> <p> source get_module_path(name: str) \u2192 Path | None </p> <p>Return the source path of the specified module name.</p> <p>Attempt to find the source path of a module given its name. Use <code>find_spec</code> to retrieve the module specification and check if the module has a valid origin. If the module is found and is a Python file, return its path. If the module cannot be found or is not a valid Python file, return None.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the module whose source path is to be retrieved.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Path | None \u2014 The source path of the module as a Path object, or None if the module does not exist or is not a valid Python file.</p> </li> </ul> <p> Examples </p> <pre><code>path = get_module_path(\"collections\")\npath.exists()\n</code></pre> <pre><code>True\n</code></pre> <pre><code>path = get_module_path(\"non_existent_module\")\npath is None\n</code></pre> <pre><code>True\n</code></pre> <p> source get_module_name(module: str) \u2192 str </p> <p>Return the name of the specified module.</p> <p>Attempt to import a module given its name and return its name as a string. If the module name is empty, return an empty string. If the module cannot be found, return the original module name provided.</p> <p> Parameters </p> <ul> <li> <p>module :  str \u2014 The name of the module to import.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The name of the imported module, or the original module name if the import fails or if the input is empty.</p> </li> </ul> <p> Examples </p> <pre><code>get_module_name(\"os\")\n</code></pre> <pre><code>'os'\n</code></pre> <pre><code>get_module_name(\"non_existent_module\")\n</code></pre> <pre><code>'non_existent_module'\n</code></pre> <pre><code>get_module_name(\"\")\n</code></pre> <pre><code>''\n</code></pre> <p> source is_package(name: str) \u2192 bool </p> <p>Return True if the specified name is a package.</p> <p>Check if the given name corresponds to a Python package. A package is identified by the presence of an <code>__init__.py</code> file in its directory. The function attempts to find the module specification using <code>find_spec</code> and checks if the module's origin is the <code>__init__.py</code> file.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the module to check.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the name is a package; otherwise, False.</p> </li> </ul> <p> source iter_submodule_names(name: str) \u2192 Iterator[str] </p> <p>Yield the names of submodules for the specified module.</p> <p>Retrieve the submodule names associated with a given module name. Use the <code>find_spec</code> function to obtain the module specification and check for submodule search locations. For each valid submodule path, yield the full name of the submodule.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the module for which to yield submodule names.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>str \u2014 The full names of the submodules found under the specified module.</p> </li> </ul> <p> source find_submodule_names(name: str, predicate: Callable[[str], bool] | None = None) \u2192 list[str] </p> <p>Return a list of submodule names.</p> <p>Retrieve the names of submodules associated with a given module name. Optionally filter the submodule names based on a provided predicate function. If no predicate is provided, all submodule names are returned.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the module for which to find submodule names.</p> </li> <li> <p>predicate :  Callable[[str], bool] | None \u2014 An optional function that takes a submodule name as input and returns True if the submodule should be included in the result. Defaults to None, which includes all submodules.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[str] \u2014 A list of the submodule names that satisfy the predicate, or all submodule names if no predicate is provided.</p> </li> </ul> <p> source get_module_node_source(name: str) \u2192 tuple[ast.Module, str] | None </p> <p>Return the AST node and source code of the specified module.</p> <p>Attempt to retrieve the source code of a module given its name. If the module is found on the filesystem, read the source code directly from the file. If the module is not found, it tries to import the module and retrieve the source code using the <code>inspect</code> module. The function returns a tuple containing the parsed Abstract Syntax Tree (AST) node and the source code as a string. If the module cannot be found or the source code cannot be retrieved, it returns None.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the module whose AST node and source code are</p> </li> <li> <p>to be retrieved.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>tuple[ast.Module, str] | None \u2014 A tuple containing the AST node and source code of the module, or None if the module cannot be found or the source code cannot be retrieved.</p> </li> </ul> <p> Examples </p> <pre><code>node, source = get_module_node_source(\"os\")\nisinstance(node, ast.Module)\n</code></pre> <pre><code>True\n</code></pre> <pre><code>isinstance(source, str)\n</code></pre> <pre><code>True\n</code></pre> <pre><code>get_module_node_source(\"non_existent_module\") is None\n</code></pre> <pre><code>True\n</code></pre> <p> source get_module_node(name: str) \u2192 ast.Module | None </p> <p>Return the AST node of the specified module.</p> <p>Retrieve the Abstract Syntax Tree (AST) node for a module given its name. Call <code>get_module_node_source</code> to obtain the AST node and source code. If the module is found, return the AST node; otherwise, return None.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the module whose AST node is to be retrieved.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>ast.Module | None \u2014 The AST node of the module, or None if the module cannot be found.</p> </li> </ul> <p> Examples </p> <pre><code>node = get_module_node(\"collections\")\nisinstance(node, ast.Module)\n</code></pre> <pre><code>True\n</code></pre> <pre><code>get_module_node(\"non_existent_module\") is None\n</code></pre> <pre><code>True\n</code></pre> <p> source get_module_source(name: str) \u2192 str | None </p> <p>Return the source code of the specified module.</p> <p>Retrieve the source code of a module given its name. Call <code>get_module_node_source</code> to obtain the Abstract Syntax Tree (AST) node and source code. If the module is found, return the source code; otherwise, return None.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the module whose source code is to be retrieved.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str | None \u2014 The source code of the module as a string, or None if the module cannot be found.</p> </li> </ul> <p> Examples </p> <pre><code>source = get_module_source(\"tempfile\")\nisinstance(source, str)\n</code></pre> <pre><code>True\n</code></pre> <pre><code>get_module_source(\"non_existent_module\") is None\n</code></pre> <pre><code>True\n</code></pre> <p> source iter_attribute_names(name: str, *, reverse: bool = False) \u2192 Iterator[str] </p> <p>Yield parent module names in a dot-separated format.</p> <p>Generate the names of parent modules for a given dot-separated module name. It can yield the names in either ascending or descending order based on the <code>reverse</code> flag. If <code>reverse</code> is set to True, yield from the full name down to the top-level module; otherwise, yield from the top-level module down to the full name.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The dot-separated name of the module for which to yield</p> </li> <li> <p>parent module names.</p> </li> <li> <p>reverse :  bool, optional \u2014 If True, yield names from the full name</p> </li> <li> <p>to the top-level module. Defaults to False.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Iterator[str] \u2014 The parent module names in dot-separated format.</p> </li> </ul> <p> Examples </p> <pre><code>list(iter_attribute_names(\"a.b.c.d\"))\n</code></pre> <pre><code>['a', 'a.b', 'a.b.c', 'a.b.c.d']\n</code></pre> <pre><code>list(iter_attribute_names(\"a.b.c.d\", reverse=True))\n</code></pre> <pre><code>['a.b.c.d', 'a.b.c', 'a.b', 'a']\n</code></pre> <p> source iter_by_name(items: Iterable[T], name: str, attr: str = 'name') \u2192 Iterator[T] </p> <p>Yield items from the iterable that match the specified name.</p> <p>Iterate over a collection of items and yield those that have a specified attribute equal to the given name. The attribute to compare can be specified using the <code>attr</code> parameter, which defaults to \"name\".</p> <p> Parameters </p> <ul> <li> <p>items :  Iterable[T] \u2014 The collection of items to iterate over.</p> </li> <li> <p>name :  str \u2014 The name to match against the specified attribute.</p> </li> <li> <p>attr :  str, optional \u2014 The attribute of the items to compare with the name. Defaults to \"name\".</p> </li> </ul> <p> Yields </p> <ul> <li> <p>T \u2014 The items that match the specified name.</p> </li> </ul> <p> source find_item_by_name(items: Iterable[T], name: str | Iterable[str], attr: str = 'name') \u2192 T | None </p> <p>Find the first item with a specified name from an iterable of items.</p> <p>Search through a collection of items and return the first item that matches the specified name. If multiple names are provided, return the first matching item found. The attribute to compare can be specified using the <code>attr</code> parameter, which defaults to \"name\". If the name is not a string, it will iterate through the provided names and return the first matching item found.</p> <p> Parameters </p> <ul> <li> <p>items :  Iterable[T] \u2014 The collection of items to search through.</p> </li> <li> <p>name :  str | Iterable[str] \u2014 The name or names to match against the specified attribute.</p> </li> <li> <p>attr :  str, optional \u2014 The attribute of the items to compare with the name. Defaults to \"name\".</p> </li> </ul> <p> Returns </p> <ul> <li> <p>T | None \u2014 The first item that matches the specified name, or None if no matching item is found.</p> </li> </ul> <p> source find_item_by_kind(items: Iterable[T], kind: str) \u2192 T | None </p> <p>Find the first item of a specified kind from an iterable of items.</p> <p>Search through a collection of items and return the first item that matches the specified kind. It uses the <code>iter_by_name</code> function to filter items based on the \"kind\" attribute.</p> <p> Parameters </p> <ul> <li> <p>items :  Iterable[T] \u2014 The collection of items to search through.</p> </li> <li> <p>kind :  str \u2014 The kind to match against the specified attribute.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>T | None \u2014 The first item that matches the specified kind, or None if no matching item is found.</p> </li> </ul> <p> source find_item_by_type(items: Iterable[Any], type_: type[T]) \u2192 T | None </p> <p>Find the first item of a specified type from an iterable of items.</p> <p>Search through a collection of items and return the first item that is an instance of the specified type. If no item of the specified type is found, return None.</p> <p> Parameters </p> <ul> <li> <p>items :  Iterable \u2014 The collection of items to search through.</p> </li> <li> <p>type_ :  type[T] \u2014 The type to match against the items.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>T | None \u2014 The first item that matches the specified type, or None if no matching item is found.</p> </li> </ul> <p> source delete_item_by_name(items: list[T], name: str, attr: str = 'name') \u2192 None </p> <p>Delete the first item with a specified name from a list of items.</p> <p>Iterate through the provided list of items and delete the first item that matches the specified name based on the given attribute. The deletion is performed in-place, modifying the original list.</p> <p> Parameters </p> <ul> <li> <p>items :  list[T] \u2014 The list of items from which to delete the matching item.</p> </li> <li> <p>name :  str \u2014 The name to match against the specified attribute of the items.</p> </li> <li> <p>attr :  str, optional \u2014 The attribute of the items to compare with the name. Defaults to \"name\".</p> </li> </ul> <p> Returns </p> <ul> <li> <p>None \u2014 This function does not return any value.</p> </li> </ul> <p> source merge_unique_names(a: Iterable[Any], b: Iterable[Any], attr: str = 'name') \u2192 list[str] </p> <p>Merge two iterables and return a list of unique names.</p> <p>Take two iterables and collect the names of their elements, ensuring that the resulting list contains only unique names. The names are extracted from the specified attribute of each element, which defaults to \"name\". If an element's name is already in the resulting list, it will not be added again.</p> <p> Parameters </p> <ul> <li> <p>a :  Iterable \u2014 The first iterable from which to collect names.</p> </li> <li> <p>b :  Iterable \u2014 The second iterable from which to collect names.</p> </li> <li> <p>attr :  str, optional \u2014 The attribute of the items to extract names from. Defaults to \"name\".</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[str] \u2014 A list of unique names collected from both iterables.</p> </li> </ul> <p> source split_filters(name: str) \u2192 tuple[str, list[str]] </p> <p>Split filters written after <code>|</code> in a given string.</p> <p>Take a string that may contain filters separated by the <code>|</code> character and split it into a base name and a list of filters. If no filters are present, return the original string as the base name and an empty list.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The input string containing the base name and optional filters.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>tuple[str, list[str]] \u2014 A tuple where the first element is the base name and the second element is a list of filters extracted from the input string.</p> </li> </ul> <p> Examples </p> <pre><code>split_filters(\"a.b.c\")\n</code></pre> <pre><code>('a.b.c', [])\n</code></pre> <pre><code>split_filters(\"a.b.c|upper|strict\")\n</code></pre> <pre><code>('a.b.c', ['upper', 'strict'])\n</code></pre> <pre><code>split_filters(\"|upper|strict\")\n</code></pre> <pre><code>('', ['upper', 'strict'])\n</code></pre> <pre><code>split_filters(\"\")\n</code></pre> <pre><code>('', [])\n</code></pre> <p> source update_filters(org: list[str], update: list[str]) \u2192 list[str] </p> <p>Update filters by merging and resolving conflicts.</p> <p>Take two lists of filters: the original list (<code>org</code>) and the list of updates (<code>update</code>). It merges these lists while ensuring that certain conflicting filters are resolved. Specifically, if both a lower and upper case filter or both long and short filters are present, the function will remove one of them based on the specified rules.</p> <p> Parameters </p> <ul> <li> <p>org :  list[str] \u2014 The original list of filters.</p> </li> <li> <p>update :  list[str] \u2014 The list of filters to update or add.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[str] \u2014 A new list of filters that combines the original and updated filters, with conflicts resolved.</p> </li> </ul> <p> Examples </p> <pre><code>update_filters([\"upper\"], [\"lower\"])\n</code></pre> <pre><code>['lower']\n</code></pre> <pre><code>update_filters([\"lower\"], [\"upper\"])\n</code></pre> <pre><code>['upper']\n</code></pre> <pre><code>update_filters([\"long\"], [\"short\"])\n</code></pre> <pre><code>['short']\n</code></pre> <pre><code>update_filters([\"short\"], [\"long\"])\n</code></pre> <pre><code>['long']\n</code></pre> <p> source is_identifier(name: str) \u2192 bool </p> <p>Return True if the name is a valid identifier, considering dot-separated parts.</p> <p>Check if the provided name is a valid Python identifier, which can include multiple parts separated by dots. Each part must be a valid identifier according to Python's naming rules. An identifier is a non-empty string that starts with a letter or underscore and can contain letters, digits, and underscores.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name to check for validity as an identifier. This</p> </li> <li> <p>can be a single identifier or a dot-separated string of identifiers.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the name is a valid identifier (or identifiers) with dots, otherwise False.</p> </li> </ul> <p> Examples </p> <pre><code>is_identifier(\"valid_identifier\")\n</code></pre> <pre><code>True\n</code></pre> <pre><code>is_identifier(\"valid.identifier\")\n</code></pre> <pre><code>True\n</code></pre> <pre><code>is_identifier(\"invalid-identifier\")\n</code></pre> <pre><code>False\n</code></pre> <pre><code>is_identifier(\"1invalid\")\n</code></pre> <pre><code>False\n</code></pre> <pre><code>is_identifier(\"\")\n</code></pre> <pre><code>False\n</code></pre> <pre><code>is_identifier(\"valid.identifier.with.dots\")\n</code></pre> <pre><code>True\n</code></pre> <p> source iter_identifiers(source: str) \u2192 Iterator[tuple[str, bool]] </p> <p>Yield identifiers and their validity from the given source string.</p> <p>Scan the provided source string and yield tuples of identifiers along with a boolean indicating whether each identifier is valid according to Python's naming rules. Identifiers can include dot-separated parts, and the function also handles quoted strings.</p> <p> Parameters </p> <ul> <li> <p>source :  str \u2014 The input string from which to extract identifiers.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Iterator[tuple[str, bool]] \u2014 A tuple where the first element is the identifier (or character) and the second element is a boolean that indicates whether the identifier is valid (True) or not (False).</p> </li> </ul> <p> Examples </p> <pre><code>list(iter_identifiers(\"valid_identifier\"))\n</code></pre> <pre><code>[('valid_identifier', True)]\n</code></pre> <pre><code>list(iter_identifiers(\"valid.identifier\"))\n</code></pre> <pre><code>[('valid.identifier', True)]\n</code></pre> <pre><code>list(iter_identifiers(\"invalid-identifier\"))\n</code></pre> <pre><code>[('invalid', True), ('-', False), ('identifier', True)]\n</code></pre> <pre><code>list(iter_identifiers(\"1invalid\"))\n</code></pre> <pre><code>[('1', False), ('invalid', True)]\n</code></pre> <pre><code>list(iter_identifiers('\"quoted string\"'))\n</code></pre> <pre><code>[('\"quoted string\"', False)]\n</code></pre> <pre><code>list(iter_identifiers(\"a.b.c\"))\n</code></pre> <pre><code>[('a.b.c', True)]\n</code></pre> <p> source list_exported_names(module: str) \u2192 list[str] </p> <p>Retrieve the list of exported names from a specified module.</p> <p>Attempt to import the given module and access its <code>__all__</code> attribute, which is a list or tuple of names that should be considered public and exported when using <code>from module import *</code>. If the module cannot be found, or if the <code>__all__</code> attribute is not defined, an empty list is returned.</p> <p> Parameters </p> <ul> <li> <p>module :  str \u2014 The name of the module from which to retrieve</p> </li> <li> <p>the exported names.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[str] \u2014 A list of exported names from the module, or an empty list if the module does not exist or has no exported names.</p> </li> </ul> <p> Examples </p> <pre><code>names = list_exported_names(\"pathlib\")\nall(x in names for x in [\"PurePath\", \"Path\", \"PosixPath\", \"WindowsPath\"])\n</code></pre> <pre><code>True\n</code></pre> <pre><code>list_exported_names(\"non_existent_module\")\n</code></pre> <pre><code>[]\n</code></pre> <p> source get_object_from_module(name: str, module: str) \u2192 object | None </p> <p>Retrieve an object from a specified module by its name.</p> <p>Attempt to import the given module and then look for the specified object within that module. The object can be nested, indicated by dot notation in the <code>name</code> parameter. If the module cannot be found or the object does not exist, None is returned.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the object to retrieve, which can include</p> </li> <li> <p>dot notation for nested objects (e.g., \"Class.method\").</p> </li> <li> <p>module :  str \u2014 The name of the module from which to retrieve the object.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>object | None \u2014 The requested object if found, or None if the module does not exist or the object cannot be found.</p> </li> </ul> <p> Examples </p> <pre><code>obj = get_object_from_module(\"Template\", \"jinja2\")\nobj.__module__, obj.__name__\n</code></pre> <pre><code>('jinja2.environment', 'Template')\n</code></pre> <pre><code>non_existent = get_object_from_module(\"NonExistent\", \"my_module\")\nnon_existent is None\n</code></pre> <pre><code>True\n</code></pre> <p> source is_dataclass(name: str, module: str) \u2192 bool </p> <p>Check if the specified object is a dataclass.</p> <p>Retrieve an object from the specified module using its name and check if it is a dataclass. A dataclass is a class that is decorated with the <code>@dataclass</code> decorator from the <code>dataclasses</code> module.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the object to check.</p> </li> <li> <p>module :  str \u2014 The name of the module from which to retrieve the object.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the object is a dataclass, otherwise False.</p> </li> </ul> <p> Examples </p> <pre><code>from astdoc.doc import Item\nis_dataclass(\"Item\", \"astdoc.doc\")\n</code></pre> <pre><code>True\n</code></pre> <pre><code>is_dataclass(\"is_dataclass\", \"astdoc.utils\")\n</code></pre> <pre><code>False\n</code></pre> <p> source is_enum(name: str, module: str) \u2192 bool </p> <p>Check if the specified object is an enum.</p> <p>Retrieve an object from the specified module using its name and check if it is a class. If it is a class, collect its base classes, excluding those from the built-in module. Each base class is returned as a tuple containing the base class name and its module.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the object to check.</p> </li> <li> <p>module :  str \u2014 The name of the module from which to retrieve the object.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the object is an enum, otherwise False.</p> </li> </ul> <p> source get_base_classes(name: str, module: str) \u2192 list[tuple[str, str]] </p> <p>Retrieve the base classes of a specified class from a module.</p> <p>Retrieve an object from the specified module using its name and check if it is a class. If it is a class, collect its base classes, excluding those from the built-in module. Each base class is returned as a tuple containing the base class name and its module.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the class whose base classes are to be retrieved.</p> </li> <li> <p>module :  str \u2014 The name of the module from which to retrieve the class.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[tuple[str, str]] \u2014 A list of tuples, where each tuple contains the name and module of a base class. If the specified class does not exist or is not a class, an empty list is returned.</p> </li> </ul> <p> Examples </p> <pre><code>base_classes = get_base_classes(\"Doc\", \"astdoc.doc\")\nbase_classes\n</code></pre> <pre><code>[('Item', 'astdoc.doc')]\n</code></pre> <pre><code>base_classes = get_base_classes(\"NonExistentClass\", \"my_module\")\nbase_classes\n</code></pre> <pre><code>[]\n</code></pre> <p> source split_module_name(name: str) \u2192 tuple[str, str | None] | None </p> <p>Split a dot-separated name into a module name and the remaining part.</p> <p>Take a dot-separated name and iterate through its components to determine the module name and the remaining part of the name. If a valid module is found, it returns the remaining name after the last valid module name. If the entire name corresponds to a valid module, it returns the module name and None. If the name belongs to a member of a module, it returns the member name and the module name. If no valid module is found, it returns None.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The dot-separated name to be split.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>tuple[str, str | None] | None \u2014 A tuple containing the remaining part of the name and the module name if a valid module is found. If the entire name corresponds to a valid module, it returns (module, None). If the name belongs to a member of a module, it returns (member name, module name). If no valid module is found and no previous module was identified, None is returned.</p> </li> </ul> <p> Examples </p> <p>'Section' is a member of 'astdoc.doc'</p> <pre><code>split_module_name(\"astdoc.doc.Section\")\n</code></pre> <pre><code>('Section', 'astdoc.doc')\n</code></pre> <p>Entire name is a valid module</p> <pre><code>split_module_name(\"astdoc.doc\")\n</code></pre> <pre><code>('astdoc.doc', None)\n</code></pre> <pre><code>split_module_name(\"invalid.module\") is None\n</code></pre> <pre><code>True\n</code></pre>"}]}